# Datenverarbeitung

In diesem Kapitel werden wir in einem ersten Schritt das Einlesen von Datensätzen in den geläufigen Datenstrurkturen kennenlernen, um in einem zweiten Schritt die Daten nach unseren Vorstellungen zu modifizieren.

**Tipp:** Zur Erstellung eigener Datensätze empfehlen wir das Kapitel [Datensätze selber erstellen](https://methodenlehre.github.io/einfuehrung-in-R/datensätze.html#datensätze-selber-erstellen) von Andrew Ellis und Boris Mayer.

Wie Eingangs erwähnt, arbeiten wir in diesem Kurs mit den Ökosystemen *tidyverse* und *strengejacke*, um Daten umfänglich modifizieren zu können. Natürlich gibt es auch andere Möglichkeiten der Datenbearbeitung. Wir sind aber davon überzeugt, dass die "tidyverse-Methode", an die sich auch strengejacke anschließt, eine sehr konsistente und eingängige Form des Arbeitens ermöglicht. 

Wie wir später noch sehen werden, erfordern viele Arten von statistischen Analysen und insbesondere Grafik-Funktionen einen Datensatz im *long*-Format. So muss mitunter erstaunlich viel Zeit für die Organisation von Daten für die weitere Analyse aufgewendet werden (diese Art von Arbeit wird oft als “data wrangling” bezeichnet). Sofern Sie einen Datensatz im *wide*-Format in ein *long*-Format transformieren wollen, empfehlen wir das Kapitel: [Reshaping: tidyr](https://methodenlehre.github.io/einfuehrung-in-R/daten-transformieren.html#reshaping-tidyr) von Andrew Ellis und Boris Mayer. 

## Vorbereitung 

Wir wollen mit dem Allbus-Datensatz (Allgemeine Bevölkerungsumfrage der Sozialwissenschaften) von 2018 arbeiten. Dieser lässt sich über GESIS unter: [Allbus 2018](https://www.gesis.org/allbus/inhalte-suche/studienprofile-1980-bis-2018/2018) herunterladen. Der Allbus 2018 liegt gleich im *long*-Format vor. 

**Anmerkung:** Der Allbus 2018 ist eine standardisierte Bevölkerungsbefragung mit überproportionaler Repräsentanz von Befragten aus den neuen Bundesländern. Um diesem Umstand gerecht zu werden, müssen die Daten des Allbus gewichtet werden. Eine ideale Voraussetzung für diesen Kurs.

Wir wollen unserem Anspruch einer zielgerichteten und forschungspraktischen Anwendung von R auch während der Bearbeitung des Allbus 2018, als Datengrundlage, gerecht werden. So greifen wir auf vergangene Forschungspublikationen zurück. Diese erlauben uns eine Orientierungslinie für kommende Beispiele zu ziehen.

Folgend erstellen wir ein Projekt in RStudio (siehe  1.8.1). Sobald der Projektordner erstellt wurde, schieben wir unseren Datensatz in den Projektordner. Durch die Festlegung unseres Arbeitsverzeichnises im Projektordner, kann R direkt auf den Datensatz zugreifen. Der Reiter `Files` sollte entsprechend so aussehen:

```{r, echo=F, fig.align='center', out.width="75%"}
knitr::include_graphics("Bilder/Files2.png")
```

Abschließend erstellen wir ein RScript (siehe 1.8.2) und laden unsere Packete: tidyverse, strengejacke und easystats (siehe 1.6).

Voila! Nun können wir den Datensatz einlesen.

## Datensatz importieren

Durch das Packet *sjlabelled* aus dem Packet *strengejacke* können wir drei verschiedene Dateiformate einlesen. 

* .sav > SPSS
* .dta > Stata
* .sas > SAS

Da wir den Allbus 2018 in .sav vorliegen haben, benutzen wir die folgende Funktion.

```{r, include=F}
library(strengejacke)
library(tidyverse)
```

```{}
# SPSS
allbus2018 <- read_spss("ALLB2018.sav")
```

**Wichtig!** Mit der Funktion `read_spss()` über das Packet sjlabelled werden alle fehlenden Werte zu `NA` konvertiert. Sofern Sie mit fehlenden Werten arbeiten wollen, empfehlen wir gegenwärtig noch das Packet `haven` über die Funktion `read_sav()` und dem Argument `user_na = TRUE` zu nutzen. Hier ist aber zu beachten, dass alle Vektoren unter der Klasse `labelled_spss` gespeichert werden. Das kann zu Problemen mit Funktionen aus externen Packeten führen. Eine Lösung wäre vorher die betreffenden Vektoren händisch in atomare Strukturen zu konvertieren (z.B. durch `unlabel()` aus sjlabelled). Zudem müssen dann alle fehlenden Werte händisch als `NA` makiert werden (`set_na()` aus sjlabelled). *Dazu aber später mehr!*

Sollten Ihre Daten in .dta oder .sas vorliegen, können Sie die folgenden Befehle nutzen.

```{}
# Stata
allbus2018 <- read_stata("Datensatz.dta")

# SAS
allbus2018 <- read_sas("Datensatz.sas")
```

**Anmerkung:** Sollten Sie andere Dateiformate nutzen wollen, bieten sich zudem die Packete `haven`, `readxl` und `readr` an. 

Die Funktion `read_spss` besitzt vier für uns relevante Argumente. Einen Überblick über die möglichen Argumente findet sich unter: `?read_spss`.

* `atomic.to.fac` = `TRUE` > Alle Variablen mit beschrifteten Ausprägungsmerkmalen werden zu Faktoren konvertiert. Für uns ist dieses Argument offensichtlich unbrauchbar, da wir viele Items vom Likert-Typ im Allbus 2018 vorfinden und diese als pseudo-metrisch behandeln wollen.
* `drop.labels` = `TRUE` > Alle Ausprägungsmerkmale ohne Fälle werden gelöscht. Eine nützliche Funktion, sofern wir nicht mit fehlenden Werten arbeiten möchten. Durch `read_spss()` über das Packet sjlabelled wurden ohnehin alle vormalig fehlenden Werte zu `NA` konvertiert. So können wir die überflüssigen Ausprägungsmerkmale einfach löschen. 
* `verbose` = `TRUE` > Es wird beim Verarbeiten der Daten ein Fortschrittsbalken eingeblendet. Nur bei großen Datensätzen relevant.
* `tag.na` = `TRUE` > Alle fehlenden Werte werden als `tagged_na` markiert. Damit werden sie in allen Berechnungen zwar als `NA` einbezogen, der große Vorteil dieses Vorgehens liegt aber im Erhalt der ursprünglichen Kodierung jener fehlenden Werte. Wir können also wie aus `SPSS` bekannt, jederzeit auf diese mit der Funktion `replace_na()` zugreifen und sie als reguläre Werte in unsere Berechungen aufnehmen. Leider funktioniert dieses Argument gegenwärtig nur mit positiven Kodierungsmerkmalen (z.B. 98, 99), aber nicht mit negativen Ausprägungsformen (-7, -8). *Wir hoffen auf eine baldige Anpassung und stehen mit den Entwicklern im Kontakt*.

Damit empfehlen wir das Argument `dop.labels` mit `TRUE bzw. T` zu aktivieren.

```{r, echo=T, collapse=T, comment="#>"}
allbus2018 <- read_spss("ALLB2018.sav", drop.labels = T)

# Noch schnell den Allbus zum tibble transformieren

allbus2018 <- tibble(allbus2018)
```

Hervorragend! Damit haben wir erfolgreich unsere Daten in R importiert.

Um bearbeitete Datensätze zu speichern, bietet sich der folgende Befehl an.

```{}
write_spss(allbus2018, path = "allbus2018")
```

Die Datei wird automatisch in unserem Projektordner abgelegt. Wir können aber auch über das Argument `path` einen neuen Speicherort definieren. 

## Erster Blick auf den Datensatz

Nachdem wir unseren Datensatz eingelesen haben, wollen wir uns zu Beginn einen Überblick über die vorhandenen Daten verschaffen. 

Mit `view()` können wir den ganzen Datensatz als zusätzliches Fenster öffnen.

```{r, results='hide'}
view(allbus2018)
```

Über den Befehl `view_df()` wird uns eine HTML-Version unseres Datensatzes im `Viewer` angezeigt. 

```{r, results='hide'}
view_df(allbus2018)
```

Der große Vorteil der zweiten Abbildung liegt offensichtlich in der reduzierten Darstellung. So können wir über die Spalte `ID` ablesen, welchen Wert unsere Variablen im Spaltenvektor des Datensatzes innehaben. Wir können entsprechend Variablen über diesen indizieren. Zudem wird uns die Variablenbezeichnung über `Name`, die Variablenbeschriftung über `Label` und die Ausprägungsmerkmale bzw. Spannweite über `Values`, sowie die Merkmalsbeschriftung über `Value Labels` ausgegeben. 

Weiterhin können wir über unsere zuvor erlernten "Grundfunktionen" einen Ausschnitt des Datensatzes generieren.

```{r, echo=T, results='hide', comment="#>"}
# Ersten 3 Fälle

head(allbus2018, n = 3)

# Letzten 5 Fälle

tail(allbus2018, n = 5)

#Ganzer Datensatz

print(allbus2018)
```

Die Anwendung unserer Grundfunktionen hat gegenwärtig noch den großen Nachteil, dass R versucht alle Variablen unseres Datensatzes abzubilden. Um das in den Griff zu bekommen, wollen wir uns in den folgenden Kapiteln mit der Datensatztransformation und dann Datenmanipulation beschäftigen. 

## Datensatz restrukturieren 

**Anmerkung:** Ab jetzt werden wir mit dem Allbus 2018 arbeiten. Um die folgenden Befehle nachvollziehen zu können, sollte Sie den Datensatz entsprechend eingelesen haben. 

Gemäß unseres forschungspraktischen Anspruchs stammen die kommenden Variablen aus einer Untersuchung politischen Wissens (Moosdorf 2020) in Bearbeitung des Allbus 2018.

**Kurze Erläuterung des Forschungsinhalts**

R verspricht eine enorme Flexibilität im Umgang mit Daten. Unmittelbar spürbar wird dieser Umstand in der Reorganisation von Datensätzen in neuen Objekten (gezielt aufgebaute eigene Datensätze). So wollen wir in einem ersten Schritt lernen, wie wir Datensätze grob restrukturieren und anschließend die Daten in einem neuen Datensatz speichern können. Unser Ziel ist es also einen eigenen, auf unsere Bedürfnisse zugeschnittenen, Datensatz zu erzeugen. Hierfür straten wir mit den folgenden Funktionen:

| Packet         | Funktion     | Verwendung                |
| :------------- | :----------- | :------------------------ |
| dplyr          | select()     | Selektieren von Variablen |
| dplyr          | filter()     | Filtern nach  Fällen mit spezifischer Ausprägung |
| dplyr          | arrange()    | Sortiert Datensatz nach bestimmter Variable |

Das dplyr Package stellt Funktionen für alle diese Aufgaben zur Verfügung (und noch viele mehr, wir betrachten hier nur eine kleine Auswahl). dplyr besteht sozusagen aus Verben (Funktionen) für all diese Operationen, und diese Funktionen können - je nach Bedarf - auf sehr elegante Weise zusammengesetzt werden.

Wir sehen uns nun der Reihe nach die verschiedenen Funktionen und deren Verwendung an. Wir verwenden immer den `%>%` Operator. Der Input Datensatz ist dabei immer als erstes Argument der Funktion zu verstehen.

### `Select()` {-}

Mit der Funktion `select()` lassen sich Variablen aus einem Datensatz gezielt auswählen. 

**Syntax:**
```{}
# Ohne Pipe
select(datensatz, variable1, variable2:variable3, -variable4)

# Mit Pipe
datensatz %>% 
  select(variable1, variable2:variable3, -variable4)
```

Mit dem Befehl `select()` wurden aus dem Datensatz `datensatz` die Variablen `variable1`, `variable2` bis `variable3` ausgewählt. `variable4` wurde weggelassen.

**Beispielcode:**
```{r, echo=T, collapse=T, comment="#>"}
# Nur Einstellung zu Leistungsprinzip (im19) im neuen Datensatz ds speichern

ds <- allbus2018 %>% 
  select(im19)

ds

# Einstellungen zum Leistungsprinzip (im19) und Befürwortung von Ungleichheit (im20) 
# in ds speichern

ds <- allbus2018 %>% 
  select(im19, im20)

ds

# Befürwortung von Ungleichheit (im20) aus ds löschen

ds <- ds %>% 
  select(-im20)

ds

# Auswahl von Einstellung zum Leistungsprinzip (im19) 
# über Befürwortung von Ungleichheit (im20)
# bis Einstellung zu sozialer Ungleichheit auf Makroebene (im21) und Mikroebene (id01)
# in ds speichern

ds <- allbus2018 %>% 
  select(im19:im21, id01)

ds
```

Wir können über `select()` auch die Reihenfolge unseres Spaltenvektors gezielt bestimmen.

```{r, echo=T, collapse=T, comment="#>"}
# Reheinfolge des Datensatz ds anpassen

ds <- allbus2018 %>% 
  select(id01, im19, im20, im21)

ds
```

**Anmerkung:** 

1. Viele Funktionen des tidyverse, auch `select()`, besitzen zusätzlich Hilfsfunktionen und erweiterte Funktionsvarianten, um gezielt mehrere Variablen nach bestimmten Kriterien einschließen zu können. In Anbetracht der umfänglichen Möglichkeiten dieses Vorgehens, können wir leider in diesem Kurs nicht darauf eingehen. Sofern Sie bedarf für Ihre eigenen Arbeiten sehen, empfehlen wir in der Packetdokumentation nachzusehen unter: [selection helpers](https://dplyr.tidyverse.org/reference/select.html) und [scoped verbs](https://dplyr.tidyverse.org/reference/scoped.html).

2. Sofern Sie einzelne Variablen im Datensatz verschieben möchten, empfehlen wir die Funktion `move_columns()` aus dem Packet *sjmisc*. 

### `Filter()` {-}

Mit der Funktion `filter()` können wir eine Auswahl von Fällen treffen, die alle eine bestimmte Ausprägung einer Variable besitzen.

**Tipp:** Wir kennen diesen Befehl aus SPSS als `select if`.

Um unsere Daten ausgiebig filtern zu können, müssen wir uns kurz mit den `logischen Operatoren` in R beschäftigen.

```{}
<                Kleiner
<=               Kleiner gleich
>                Grösser
>=               Grösser gleich
==               Gleich (testet auf Äquivalenz)
!=               Ungleich
x | y            x ODER y
x & y            x UND y
xor(x, y)        Exklusives ODER (entweder in x oder y, aber nicht in beiden)
```

Die `logischen Operatoren` in R sind recht selbsterklärend und sollten bei eigener Anwendung recht schnell verstanden sein.

Zusätzlich brauchen wir noch einen `infix operator`.

```{}
%in%             Merkmale in einem Vektor
```


**Syntax:**

```{}
# Ohne Pipe
filter(datensatz, variable1 == 1)

# Mit Pipe
datensatz %>% 
  filter(variable1 == 1)
```

Mit dem Befehl `filter()` wurden nur die Fälle des Datensatzes `datensatz` mit der Ausprägung `1` der Variable `variable1` übernommen. 

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Auswahl unserer bekannten Variablen gefiltert nach Personen mit NUR der 
# deutschen Staatsbürgerschaft

ds <- allbus2018 %>% 
  select(im19:im21, id01, german) %>% 
  filter(german == 1)

ds

# Auswahl unserer bekannten Variablen gefiltert nach Personen mit der 
# deutschen Staatsbürgerschaft (auch mit weiteren)

ds <- allbus2018 %>% 
  select(im19:im21, id01, german) %>% 
  filter(german %in% 1:2)

ds

# Auswahl unserer bekannten Variablen gefiltert nach Personen mit der 
# deutschen Staatsbürgerschaft (auch mit weiteren) und weiblichem Geschlecht

ds <- allbus2018 %>% 
  select(im19:im21, id01, german, sex) %>% 
  filter(german %in% c(1,2) & sex == 2)

ds
```

### `Arrange()` {-}

Mit `arrange()` können wir Beobachtungen sortieren, entweder in aufsteigender oder in absteigender Reihenfolge.

**Syntax:** 

```{}
# aufsteigend
arrange(datensatz, variable1)

datensatz %>% 
  arrange(variable1)

# absteigend
arrange(datensatz, desc(variable1))

datensatz %>% 
  arrange(desc(variable1))
```

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Sortieren nach Alter aufsteigend

ds <- allbus2018 %>% 
  select(age, im19:im21, id01, german, sex) %>% 
  arrange(age)

ds

# Sortieren nach Alter absteigend

ds <- allbus2018 %>% 
  select(age, im19:im21, id01, german, sex) %>% 
  arrange(desc(age))

ds
```

## Daten konvertieren 

So wollen wir uns den Funktionen zuwenden, die Datentypen verändern.

**Anmerkung:** Wir benutzen die Packete *sjmisc* und *sjlabelled* zur Konvertierung von Datentypen, weil die Anwendung der `base R` Funktionen alle Beschriftungen (siehe 3.3) unseres Datensatzes entfernen würde. Zudem sind die `base R` Funktionen nicht für die Nutzung in einer `Pipe` optimiert. 

| Packet         | Funktion            | Verwendung                |
| :------------- | :------------------ | :------------------------ |
| sjlabelled     | to_factor()         | Konvertiert Variable in Faktor mit numerischen `levels` |
| sjlabelled     | to_label()          | Konvertiert Variable in Faktor mit beschrifteten `levels` |
| sjlabelled     | to_numeric()        | Konvertiert Variable in numerischen Vektor |
| sjlabelled     | to_character()      | Konvertiert Variable in `character` Vektor |
| sjmisc         | numeric_to_factor() | Konvertiert Variablen mit n Ausprägungsmerkmalen zu Faktor |
| sjlabelled     | unlabel()           | Konvertiert `labelled class` in `atomare Struktur` |
| sjmisc         | ref_lvl()           | Setzt Referenzkategorie |

### `To_factor()` {-}

Konvertiert einen Vektor in einen Faktor mit numerischen `levels` - äquivalent zur Funktion `factor()`. Sinnvoll bei Variablen mit mehr als zwei Ausprägungsmerkmalen.

**Syntax:**

```{}
# Ohne Pipe
to_factor(datensatz$variable1, datensatz$variable2)

# Mit Pipe
datensatz %>% 
  to_factor(variable1, variable2)
```

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Geschlecht unbearbeitet

class(allbus2018$sex)

# Geschlecht in Faktor mit numerischen levels konvertieren

ds <- allbus2018 %>% 
  select(sex) %>% 
  to_factor(sex)

attributes(ds$sex)
```

### `To_label()` {-}

Konvertiert einen Vektor in einen Faktor mit beschrifteten `levels`. Sinvoll bei binären Ausprägungsmerkmalen.

**Syntax:**

```{}
# Ohne Pipe
to_label(datensatz$variable1, datensatz$variable2)

# Mit Pipe
datensatz %>% 
  to_label(variable1, variable2)
```

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Geschlecht in Faktor mit beschrifteten levels konvertieren

ds <- allbus2018 %>% 
  select(sex) %>% 
  to_label(sex)

attributes(ds$sex)
```

### `To_numeric()` {-}

Konvertiert einen Faktor oder `character` Vektor in einen numerischen Vektor. 

**Syntax:**

```{}
# Ohne Pipe
to_numeric(datensatz$variable1, datensatz$variable2)

# Mit Pipe
datensatz %>% 
  to_numeric(variable1, variable2)
```

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Geschlecht in Faktor 

ds <- allbus2018 %>% 
  select(sex) %>% 
  to_factor(sex)

# Geschlecht wieder in numerischen Vektor konvertieren

ds <- ds %>% 
  select(sex) %>% 
  to_numeric(sex)

class(ds$sex)
```

### `To_character()` {-}

Konvertiert einen numerischen Vektor oder Faktor in einen `character` Vektor.

**Syntax:**

```{}
# Ohne Pipe
to_character(datensatz$variable1, datensatz$variable2)

# Mit Pipe
datensatz %>% 
  to_character(variable1, variable2)
```

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Geschlecht in character Vektor konvertieren

ds <- allbus2018 %>% 
  select(sex) %>% 
  to_character(sex)

class(ds$sex)

# Folge: Alle numerischen Ausprägungsmerkmale wurden in ihre Beschriftung umgewandelt

str(ds$sex)
```

### `Numeric_to_factor()` {-}

Diese Funktion ermöglicht es uns alle Variablen eines Datensatzes anzuwählen und diese zu einem Faktor zu konvertieren. Wir müssen lediglich eine Maximalgrenze (n) als gewünschten Grenzwert zur Umwandlung angeben. Hat eine Variable weniger oder gleich viele Ausprägungsmerkmale wird sie konvertiert.

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Datensatz als Ausgangspunkt 

ds <- allbus2018 %>% 
  select(im19:im21, id01)

class(ds$im19)

# Alle Variablen haben nur bis zu vier Ausprägungsmerkmale
# Wir können sie entsprechend zu Faktoren konvertieren
# ACHTUNG: Diese Funktion ändert den Datentyp unseres Datensatzes! 
# Wir geben also zusätzliche die Funktion tibble() an

ds <- ds %>% 
  numeric_to_factor(n = 4) %>% 
  tibble()

class(ds$im19)
```

**Wichtig!** Die Funktion `numeric_to_factor()` hat die gleiche Wirkung wie die Funktion `to_label()`. Wir sparen uns lediglich den Aufwand jede Variable einzeln anzuwählen. 

### `Unlabel()` {-}

Mit dieser Funktion können wir Variablen konvertieren, die als `labelled class` gespeichert wurden. Durch das Einlesen unseres Datensatzes über `read_spss()` werden wir diesen Befehl praktisch nie brauchen. Sollte wir den Datensatz aber über `haven` mit der Funktion `read_sav()` laden, ist es sinnvoll alle Variablen nach der Bearbeitung in eine `atomare Struktur` umzuwandeln - damit lassen sich spätere Probleme mit zusätzlichen Packeten vorbeugen.

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Datensatz laden und vorbereiten

library(haven)

allbus2018_haven <- read_sav("ALLB2018.sav")

ds <- allbus2018_haven %>% 
  select(age, im19:im21, id01, german, sex)

# Beispiel

class(ds$age)

# Wir konvertieren alle Variablen
# ACHTUNG: Diese Funktion ändert den Datentyp unseres Datensatzes! 
# Wir geben also zusätzliche die Funktion tibble() an

ds <- ds %>% 
  unlabel() %>% 
  tibble()

class(ds$age)
```

```{r, include=F}
detach("package:haven", unload = TRUE)
```

### `Ref_lvl()` {-}

Die Verwendung der Funktion `rev_lvl()` aus *sjmisc* hat den großen Vorteil, dass unser Faktor im Gegensatz zur Funktion `relevel()` rekodiert wird und damit alle Beschriftungen auch bei numerischen `levels` richtig zugewiesen werden können. 

**Syntax:**

```{}
# Ohne Pipe
rev_lvl(datensatz, variable1, lvl = 3)

# Mit Pipe
datensatz %>% 
  ref_lvl(variable1, lvl = 3)
```

Wir ändern mit der Funktion `ref_lvl()` die Referenzkategorie von `variable1` auf das Ausprägungsmerkmal `3`.

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Geschlecht als Faktor

ds <- allbus2018 %>% 
  select(sex) %>% 
  to_factor(sex)

# Unsere Refrenzkategorie ist gegenwärtig "Mann"
attributes(ds$sex)

# Wir ändern die Refrenkategorie folgend auf "Frau"

ds <- ds %>% 
  ref_lvl(sex, lvl = 2)

attributes(ds$sex)
```

## Daten beschriften

Grundständig kennt R keine beschrifteten Daten. Erst durch den zunehmenden Einfluss sozialwisschenschaftlicher Anwendungsbedürfnisse und der bevorzugten Datenformate (.sav, .dta, .sas) halten Datenbeschriftungen auch in die R-Umgebung Einzug. 

| Packet         | Funktion            | Verwendung                |
| :------------- | :------------------ | :------------------------ |
| sjlabelled     | get_label()         | Ruft Variablenbeschriftung ab |
| sjlabelled     | get_labels()        | Ruft Beschriftung von Ausprägungsmerkmalen ab |
| sjlabelled     | remove_label()      | Entfernt Variablenbeschriftung |
| sjlabelled     | remove_labels()     | Entfernt Beschriftung von Ausprägungsmerkmalen |
| sjlabelled     | remove_all_labels() | Entfernt alle Beschriftungen |
| sjlabelled     | var_labels()        | Variable neubeschriften |
| sjlabelled     | val_labels()        | Ausprägungsmerkmale neubeschriften |
| sjlabelled     | drop_labels()       | Alle "unbesetzten" Ausprägungsmerkmale löschen |*

*Die Funktion `drop_labels()` ist äquivalent zum Argument `drop.labels = T` in der Funktion `read_spss()`. Sofern Sie ihre Daten mit `read_sav()` eingelesen haben, können Sie diesen Befehl nach der Bearbeitung ihres Datensatzes zur Löschung überflüssiger Merkmalsausprägungen nutzen.

### `Get_label()` {-}

Mit der Funktion `get_label()` können wir Variablenbeschriftungen abrufen.

**Syntax:**

```{}
# Ohne Pipe
get_label(datensatz, variable1)

# Mit Pipe
datensatz %>% 
  get_label(variable1)
```

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Variablenbeschriftung Leistungsprinzip (im19) 
# und Befürwortung von Ungleichheit (im20)

allbus2018 %>% get_label(im19, im20)
```

### `Get_labels()` {-}

Die Funktion `get_labels()` erlaubt uns das Abrufen der Beschriftung von Merkmalsausprägungen.

**Syntax:**

```{}
# Ohne Pipe
get_labels(datensatz, variable1)

# Nicht mit Pipe möglich!
```

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Beschriftung der Ausprägungsmerkmale - Leistungsprinzip (im19) 

get_labels(allbus2018$im19)
```

### `Remove_label()` {-}

Über die Funktion `remove_label()` lassen sich gezielt Variablenbeschriftungen von einzelnen Variablen oder allen Variablen im Datensatz entfernen.

**Syntax:**

```{}
# Einzelne Variable
# Ohne Pipe
remove_label(datensatz, variable1)

# Mit Pipe
datensatz %>%
  remove_label(variable1)
  
# ---------
  
# Ganzer Datensatz
# Ohne Pipe
remove_label(datensatz)

# Mit Pipe
datensatz %>%
  remove_label()
```

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Löschung der Variablenbeschriftung - Geschlecht

ds <- allbus2018 %>% 
  select(sex) %>% 
  remove_label(sex)

# Variablenbeschriftung wurde gelöscht

ds %>% get_label(sex)

# Löschung aller Variablenbeschriftungen im Datensatz

ds <- allbus2018 %>% 
  select(im19, im20) %>% 
  remove_label()

# Variablenbeschriftungen wurden gelöscht

ds %>% get_label(im19, im20)
```

### `Remove_labels()` {-}

Die Funktion `remove_labels()` erlaubt es uns gezielt Beschriftungen der Ausprägungsmerkmale von einzelnen Variablen oder allen Variablen im Datensatz zu löschen.

**Syntax:**

```{}
# Ohne Pipe
remove_labels(datensatz, variable1)

# Mit Pipe
datensatz %>%
  remove_labels(variable1)
  
# ---------
  
# Ganzer Datensatz
# Ohne Pipe
remove_labels(datensatz)

# Mit Pipe
datensatz %>%
  remove_labels()
```

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Löschung der Variablenbeschriftung - Geschlecht

ds <- allbus2018 %>% 
  select(im19) %>% 
  remove_labels(im19, labels = c(1, 2, 3, 4))

# Variablenbeschriftung wurde gelöscht

get_labels(ds$im19)

# Löschung aller Variablenbeschriftungen im Datensatz

ds <- allbus2018 %>% 
  select(im19, im20) %>% 
  remove_labels(labels = 0:99)

# Variablenbeschriftungen wurden gelöscht

get_labels(ds$im19)
get_labels(ds$im20)
```

### `Remove_all_labels()` {-}

Wir können mit der Funktion `remove_all_labels()` **alle** (Variablenbeschriftungen und Beschriftungen von Merkmalsausprägungen) löschen.

**Syntax:**

```{}
# Ohne Pipe
remove_all_labels(datensatz, variable1)

# Mit Pipe
datensatz %>% 
  remove_all_labels(variable1)
```

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Löschung aller Beschriftungen in einem Datensatz

ds <- allbus2018 %>% 
  select(im19, im20) %>% 
  remove_all_labels()

# Variablenbeschriftungen wurden gelöscht

ds %>% get_label(im19, im20) 

# Beschriftung von Ausprägungsmerkmalen wurden gelöscht

get_labels(ds$im19)
get_labels(ds$im20)
```

### `Var_labels()` {-}

Mit der Funktion `var_labels()` können wir von einer oder mehreren Variablen die Variablenbeschriftung neu definieren.

**Syntax:**

```{}
# Ohne Pipe
var_labels(datensatz, variable1 = "Variablenbeschriftung")

# Mit Pipe
datensatz %>% 
  var_labels(variable1 = "Variablenbeschriftung")
```

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Variablenbeschriftung neu definieren

ds <- ds %>% 
  var_labels(im19 = "Leistungsprinzip",
             im20 = "Befürwortung von Ungleichheit")

# Variablenbeschriftungen abrufen

ds %>% get_label(im19, im20)
```

### `Val_labels()` {-}

Die Funktion `val_labels()` erlaubt es uns Ausprägungsmerkmale für eine oder mehrere Variablen neu zu definieren.

**Syntax:**

```{}
# Ohne Pipe
var_labels(datensatz, variable1 = c("1", "2"))

# Mit Pipe
datensatz %>% 
  var_labels(variable1 = c("1", "2"),
             variable2 = c("Hallo", "Tschüss"))
```

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Merkmalsausprägungen neu definieren

ds <- ds %>% 
  val_labels(im19 = c("Erste Stufe", "Zweite Stufe", "Dritte Stufe", "Vierte Stufe"),
             im20 = c("Erste Stufe", "Zweite Stufe", "Dritte Stufe", "Vierte Stufe"))

get_labels(ds$im19)
get_labels(ds$im20)

ds %>% 
  select(im19, im20) %>% 
  view_df()
```

## Daten manipulieren

Zur Manipulation/Bearbeitung unseres Datensatzes werden wir maßgeblich mit dem `dplyr`-Packet aus dem tidyverse und dem Packet `sjmisc` aus `strengejacke` arbeiten. Die folgende Auswahl kann nur einen Überblick über die "wichtigsten" Funktionen dieser Packete geben. Sofern Sie weitere Tranformationswünsche haben, sollten Sie unbedingt die Entwicklerseiten dieser Packete aufsuchen und nach geeigneten Funktionen suchen (siehe 1.6).


| Packet         | Funktion     | Verwendung                |
| :------------- | :----------- | :------------------------ |
| dplyr          | rename()     | Umbenennen von Variablen  |
| dplyr          | mutate()     | Erstellen und verändern von vorhandenen Variablen  |
| dplyr          | group_by()   | Erstellt Gruppen (Teilmengen) |
| dplyr          | summarise()  | Daten zusammenfassen  |
| dplyr          | distinct()   | Auswahl einzigartiger Werte |
| dplyr          | case_when()  | Vektorisierter if-Befehl  |
| sjmisc         | rec()        | Rekodierung von Variablen  |
| sjmisc         | std()        | Z-Standardisierung von Variablen  |
| sjmisc         | center()     | Zentrierung von Variablen am Mittelwert  |
| sjmisc         | split_var()  | Aufspaltung von Variablen in n Gruppen gleicher Größe |
| sjmisc         | group_var()  | Aufspaltung von Variablen in Gruppen gleicher Spannweite |
| sjmisc         | row_count()  | Zählung von Zeilenwerten  |
| sjmisc         | row_sums()   | Summe der Zeilenwerte |
| sjmisc         | row_means()  | Mittelwert der Zeilenwerte |
| sjlabelled     | set_na()     | Transformiert Ausprägungsmerkmale zu fehlenden Werten |
| tidyr          | drop_na()    | Alle fehlenden Werte werden gelöscht |

### `Rename()` {-}

Die Funktion `rename()` erlaubt uns eine Neubeschriftung der Variablennamen vorzunehmen.

**Wichtig!** Die nicht umbenannten Variablen verbleiben auch weiterhin im Datensatz.

**Syntax:** 

```{}
# Ohne Pipe
rename(datensatz, rename(variableA = variable1))

# Mit Pipe
datensatz %>% 
  rename(variableA = variable1)
```

Mit dem Befehl `rename()` haben wir in unserem Datensatz `ds` die Variable `variable1` in `variableA` umbenannt. Der neue Name muss folgend immer auf der *linken* Seite der Gleichung stehen.

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Neubeschriftung der Variablen Geschlecht (sex) und Alter (age)

ds <-  allbus2018 %>% 
  select(sex, age) %>% 
  rename(Geschlecht = sex,
         Alter = age)

ds
```

### `Mutate()` {-}

Über die Funktion `mutate()` können wir neue Variablen aus schon bestehenden Variablen bilden. Vor allem erlaubt uns dieser Befehl mathematische Operationen an Variablen vorzunehmen. Wir kennen diese Befehl in `SPSS` als `compute`.

**Syntax:** 

```{}
# Ohne Pipe
mutate(datensatz, variable1 = Berechnung)

# Mit Pipe
datensatz %>% 
  mutate(variable1 = Berechnung)
```

Die Funktion `mutate()` erstellt eine neue Variable mit dem Namen `variable1`, in der wir das Ergebnis aus `Berechnung` speichern.

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Berechung des Alters der Befragten aus ihrem Geburtsjahr in neuer Variable (Alter)

ds <-  allbus2018 %>% 
  select(yborn, age) %>% 
  mutate(Alter = 2018-yborn)

ds

# Fast ;D
# Um das korrekte Alter zu ermitteln, müssten wir natürlich noch den Geburtsmonat einbeziehen!
```

Sofern Sie nur die neu gebildeten Variablen in ihrem Datensatz behalten möchten, bietet sich der Befehl `transmute()` als Erweiterung von `mutate()` an.

### `Group_by()` {-}

Gesetzt den Fall, dass wir bestimmte Operationen nicht auf den ganzen Datensatz anwenden wollen, sondern nur auf Teilgruppen, ist die Funktion `group_by()` die ideale Lösung für uns. Über `group_by()` wird unser Datensatz anhand einer Gruppierungsvariable (mit nominalen Ausprägungsmerkmalen) geteilt. Anschließende Funktionen werden auf jeden Teil angewendet, bevor sich der Datensatz nach Abschluss unserer Operationen über wieder zusammensetzt (split-apply-combine). `group_by()` wird deshalb meistens in Kombination mit anderen Funktionen verwendet. Um nach einer abgeschlossenen Operation die Gruppierung wieder zusammen zu setzen, nutzen wir `ungroup()`. So können wir wieder mit einem ungruppierten Datensatz weiterarbeiten. Unsere Ergebnisse können wir über `mutate()` einer neuen Variable zuweisen und es damit auf alle Fälle in unserem Datensatz übertragen. 

**Syntax:** 

```{}
# Ohne Pipe
group_by(datensatz, variable1)

# Mit Pipe
datensatz %>% 
  group_by(variable1)
```

Wir spalten also über die Funktion `group_by()` unseren Datensatz in Gruppen nach den Ausprägungsmerkmalen der `variable1`.

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Altersdurchschnitt nach Ost und West 

ds <- allbus2018 %>% 
  select(age, eastwest, wghtpew) %>% 
  group_by(eastwest) %>% 
  # Wir werden in Kapitel 4 alles über gewichtete Objekte lernen (z.B. weighted_mean())!
  mutate(alterOstWest = weighted_mean(age, weights = wghtpew)) %>% 
  ungroup() 

ds %>% select(eastwest, alterOstWest)
```

Unter Verwendung von `group_by()` haben wir den Datensatz in zwei separate Teile geteilt und dann den Gruppenmittelwert für Ost- und Westdeutschland errechnet. Da wir unser Ergebnis allen Fällen zuweisen wollten, haben wir eine neue Variable über `mutate()` gebildet. Anschließend haben wir die Teile wieder über `ungroup()` “zusammengesetzt” (d.h. es ist wieder ein Datensatz) und so das Ergebnis allen Fällen zugewiesen. Als Resultat besitzen alle Fälle den Altersdurchschnitt in ihrem Bundesgebiet als neue Variable `alterOstWest`.

### `Summarise()` {-}

Die Funktion `summarise()` ermöglicht es uns Variablen zusammen zu fassen und deskriptive Kennzahlen zu berechnen. Im Gegensatz zu `mutate()` gibt `summarise()` aber nicht den Wert für jede Beobachtung als Output aus, sondern einen Wert für jede Gruppe. `summarise()` wird oft zusammen mit `group_by()` verwendet.

**Syntax:**

```{}
# Ohne Pipe
summarise(datensatz, variable1 = funktion(variable))

# Mit Pipe
datensatz %>% 
  summarise(variable1 = funktion(variable))
```

Mit der Funktion `summarise()` wurde in `variable1` das Ergebnis aus `function(variable)` gespeichert. Hierbei wurde ein neuer Datensatz mit nur der Variable `variable1` gebildet, die als einzigen Wert den Gruppenwert aus `function(variable)` besitzt. 

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Altersdurchschnitt nach Ost und West 

ds <- allbus2018 %>% 
  select(age, eastwest, wghtpew) %>% 
  group_by(eastwest) %>% 
  summarise(alterOstWest = weighted_mean(age, weights = wghtpew)) %>% 
  ungroup() 

ds %>% select(eastwest, alterOstWest)
```

### `Distinct()` {-}

Die Funktion `distinct()` erlaubt uns einzigartige Werte in einem Vektor zu ermitteln.

**Syntax:**

```{}
# Ohne Pipe
distinct(datensatz, variable1)

# Mit Pipe
datensatz %>% 
  distinct(datensatz, variable1)
```

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Geburtsjahre

ds <- allbus2018 %>% 
  select(yborn) %>% 
  distinct(yborn) %>% 
  arrange(yborn)

ds
```

### `Case_when()` {-}

Über die Funktion `case_when()` lassen sich Kombinationen von Ausprägungsmerkmalen in neuen Variablen speichern - (Stw. Kombinationsindex). Der Befehl `if-Befehl` aus `SPSS` kommt diesem sehr nahe.

**Syntax:**

```{}
# Ohne Pipe
case_when(datensatz$variable1 == 1 & datensatz$variable2 == 2 ~ 1,
          datensatz$variable1 == 2 $ datensatz$variable2 == 1 ~ 2)

# Mit Pipe
datensatz %>%
  mutate(variableA = case_when(variable1 == 1 & variable2 == 2 ~ 1,
                               variable1 == 2 $ variable2 == 1 ~ 2)
```

Die Funktion `case_when()` erzeugt aus den Ausprägungsmerkmalen `1` und `2` der Variablen `variable1` und `variable2` eine neue Ausprägung `1`. Das gleiche passiert auch in den nachfolgenden Operationen mit verschiedenen Wertpaaren der `variable1` und `variable2`. 

**Anmerkung:** Die Funktion `case_when()` kann innerhalb einer `Pipe` praktisch nicht ohne eine "Speicherfunktion" auskommen. Entsprechend haben wir hier `mutate()` vorangestellt. 

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Postmaterialismusindex nach Inglehart: Materialisten/Postmaterialisten

ds <- allbus2018 %>%
  select(va01:va04, ingle) %>%
  mutate(
    inglehartIndex = case_when(
      # Materialisten
      va01 == 1 & va03 == 2 ~ 4,
      va01 == 2 & va03 == 1 ~ 4,
      # Postmaterialisten
      va02 == 1 & va04 == 2 ~ 1,
      va02 == 2 & va04 == 1 ~ 1
    )
  )

# Vergleich mit dem beigelegten Inglehartindex aus dem Allbus
# Wir müssten natürlich noch die Mischtypen berechnen!

ds %>% 
  select(inglehartIndex, ingle) %>% 
  filter(inglehartIndex %in% c(1, 4))
```

### `Rec()` {-}

Nun folgt die wohl wichtigste Funktion in unserem Werkzeugkasten. So vereint die Funktion `rec()` eine Vielzahl von uns bekannten Funktionen z.B. `to_numeric() und to_factor()`, `var_labels() und val_labels()` und schafft darüber hinaus die Möglichkeit zur gezielten Rekodierung von Variablen. Diese Funktion entspricht dem Befehl `recode` aus `SPSS`.

**Syntax:**

```{}
# Ohne Pipe
rec(datensatz, variable1, rec = "1=1 [niedrig]; 2,4=2 [mittel]; 4:max=3 [hoch], else=copy, 99=NA", 
                          var.label = "Variablenbeschriftung", to.factor = TRUE)

# Mit Pipe
datensatz %$% 
  rec(variable1, rec = "1=1 [niedrig]; 2,3=2 [mittel]; 4:max=3 [hoch], else=copy, 99=NA", 
                 var.label = "Variablenbeschriftung", to.factor = TRUE)
```

`variable1` aus dem Datensatz `datensatz` wurde rekodiert und in einen Faktor konvertiert. So wurden alle Werte entsprechend neu zugewiesen und mit neuen Beschriftungen versehen. Zudem wurde die Variablenbeschriftung angepasst.

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Rekodierung von Bildungsabschlüssen

ds <- allbus2018 %>% 
  select(educ) %>% 
  mutate(bildung = rec(educ, rec = "1,2=1 [gering];  3,7=2 [mittel]; 4,5=3 [hoch]",
                       var.label = "Bildung kategorisiert", to.factor = T))

class(ds$educ)

attributes(ds$bildung)

view_df(ds)
```

### `Std()` {-}

**Syntax:**

```{}
# Ohne Pipe
std(datensatz, variable1)

# Mit Pipe
datensatz %>% 
  std(datensatz, variable1)
```

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# z-Standardisierung des Leistungsprinzip (im19)

ds <- allbus2018 %>% 
  select(im19, wghtpew) %>% 
  std(im19, weights = wghtpew)

ds %>% select(im19, im19_z)
```

Suffix erklären!

### `Center()` {-}

**Syntax:**

```{}
# Ohne Pipe
center(datensatz, variable1)

# Mit Pipe
datensatz %>% 
  center(datensatz, variable1)
```

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Zentrierung des Leistungsprinzip (im19) am Mittelwert

ds <- allbus2018 %>% 
  select(im19, wghtpew) %>% 
  center(im19, weights = wghtpew)

ds %>% select(im19, im19_c)
```

### `Split_var()` {-}

**Syntax:**

```{}
# Ohne Pipe
split_var(datensatz, variable1, n = 5)

# Mit Pipe
datensatz %>% 
  split_var(datensatz, variable1, n = 5)
```

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Alter in 5 gleichgroße Gruppen unterteilen

ds <- allbus2018 %>% 
  select(age) %>% 
  mutate(ageGrp = split_var(age, n = 5))

# Den Befehl frq() werden wir in Kapitel 4 umfassend besprechen!
ds %>% frq(ageGrp, weights = allbus2018$wghtpew)
```

### `Group_var()` {-}

**Syntax:**

```{}
# Ohne Pipe
group_var(datensatz, variable1, size = 5)

# Mit Pipe
datensatz %>% 
  group_var(datensatz, variable1, size = 5)
```

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# 10 Jahre Altersspannen 
# Achtung! Intervalle orientieren sich "default" an der oberen Wertgrenze des Intervalls

ds <- allbus2018 %>% 
  select(age) %>% 
  mutate(ageGrp = group_var(age, size = 10))

# Eine direkte Beschriftung ist leider nicht möglich.
# Zum Abgleich der Intervallgrenzen ist group_labels() aber sehr hilfreich!
# Group_labels() generiert in gleicher Form die gewüschten Intervalle, besitz aber als Ausprägungsmerkmale die Beschriftung. 

group_labels(ds$age, size = 10)

# Beschriftung der Intervalle 

ds <- ds %>% 
  val_labels(ageGrp = c("10-19", "20-29", "30-39", "40-49", "50-59", "60-69", "70-79", "80-89", "90-99"))

attributes(ds$ageGrp)
```

### `Row_count()` {-}

Befehl `count` in `SPSS`. Noch suchen: count für mehrere Werte!

**Syntax:**

```{}
# Ohne Pipe
row_count(datensatz, count = 1)

# Mit Pipe
datensatz %>% 
  row_count(count = 1)
```

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Mitgliedsstatus in Vereinen zählen - aktives Mitglied (3)

ds <- allbus2018 %>% 
  select(sm04:sm14) %>% 
  row_count(count = 3)

ds %>% frq(rowcount, weights = allbus2018$wghtpew)
```

### `Row_sums()` {-}

Summenindex

```{}
# Ohne Pipe
row_sums(datensatz, n = Inf)

# Mit Pipe
datensatz %>% 
  row_sums(n = Inf)
```

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Mitgliedsstatus in Vereinen zählen 

ds <- allbus2018 %>% 
  select(sm04:sm07) %>% 
  row_sums(n = Inf)

ds %>% frq(rowsums, weights = allbus2018$wghtpew)
```

### `Row_means()` {-}

Mittelwertindex

```{}
# Ohne Pipe
row_means(datensatz, n = 1)

# Mit Pipe
datensatz %>% 
  row_means(n = 1)
```

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Mittelwertindex: Leistungsprinzip (im19) und Befürwortung von Ungleichheit (im20)

ds <- allbus2018 %>% 
  select(im19, im20) %>% 
  row_means(n = 1)

ds %>% frq(rowmeans, weights = allbus2018$wghtpew)
```


### `Set_na()` {-}

Mit der Funktion `set_na()` wollen wir lernen, wie wir einzelne oder mehrere Ausprägungsmerkmale in `NA` konvertieren können.

**Syntax:**

```{}
# Ohne Pipe
set_na(datensatz, variable1, na = c(1, 3))

# Mit Pipe
datensatz %>% 
  set_na(variable1, na = c(1, 3))
```

Mit haben mit der Funktion `set_na()` in `variable1` die Ausprägungsmerkmale `1` und `3` als `NA` definiert. 

**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Definition der Altersspanne 61 bis 99 als NA

ds <- allbus2018 %>% 
  select(age) %>% 
  set_na(age, na = 61:99)

view_df(ds)
```

### `Drop_na()` {-}

**Syntax:**

```{}
# Einzelne Variable
# Ohne Pipe
drop_na(datensatz, variable1)

# Mit Pipe
datensatz %>% 
  drop_na(variable1)

# --------

# Ganzer Datensatz
# Ohne Pipe
drop_na(variable1)

# Mit Pipe
datensatz %>% 
  drop_na()
```


**Beispielcode:**

```{r, echo=T, collapse=T, comment="#>"}
# Fehlende Werte in Leistungsprinzip (im19) löschen

ds <- allbus2018 %>% 
  drop_na(im19)
  
allbus2018 %>% frq(im19, weights = wghtpew)

ds %>% frq(im19, weights = wghtpew)

# Alle fehelnden Werte im Datensatz löschen

ds1 <- allbus2018 %>% 
  select(im19, im20, wghtpew)

ds2 <- ds1 %>% 
  drop_na()

ds1 %>% frq(im19, im20, weights = wghtpew)

ds2 %>% frq(im19, im20, weights = wghtpew)
```



**Referenz:**

**Moosdorf, D. (2020):** Kritik an sozialer Ungleichheit – Macht politisches Wissen den Unterschied?. In Tausendpfund, M. & B. Westle (Hrsg.), Politisches Wissen in Deutschland: Empirische Analysen mit dem ALLBUS 2018 (S. 165–197). Wiesbaden: Springer VS. https://doi.org/10.1007/978-3-658-30492-8_6.




