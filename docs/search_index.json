[["index.html", "R Workshop - Sozialwissenschaften Vorwort 0.1 Voraussetzungen 0.2 Warum R? 0.3 Was ist R? 0.4 Aller Einstieg ist schwer?! 0.5 Typographie 0.6 Weiterführende Literatur", " R Workshop - Sozialwissenschaften Yannick Diehl und Daniel Moosdorf 2021-05-21 Vorwort Dieser Workshop richtet sich insbesondere an Studierende der Sozialwissenschaften und möchte einen einfachen und verständlichen Einstieg in statistische Auswertungen mit R bieten. Ein besonderer Augenmerk liegt auf Anwender:innen die eine neue Heimat zur Lösung statistischer Aufgaben- und Problemstellungen suchen und folgend Kenntnisse im Umgang mit (u.a. kommerziellen) Statistik- und Analyse-Software besitzen (v.a. SPSS). Anwendungsziel der kommenden Analysetechniken sind insbesondere sozialwissenschaftliche Studien/Bevölkerungsumfragen mit wissenschaftlichen Erhebungsstandards, wenngleich auch “unstandartisierte” Datensätze mit den vorzustellenden Techniken verarbeitet werden können. Zudem soll den künftigen Anwender:innen eine umfassende Funktionsbibliothek an die Hand gegeben werden, welche eine komplexe Gewichtung von Studiendaten erlaubt. 0.1 Voraussetzungen Bitte installieren Sie hierfür die aktuelle Version von R unter: R Programm - Version 4.0.5 (17.05.2021) Darüber hinaus werden wir mit der integrierten Entwicklungsumgebung (IDE) RStudio arbeiten. Die aktuelle Version findet sich unter: RStudio Desktop Intergrierte Entwicklungsumgebungen wie RStudio vereinfachen den Arbeitprozess mit der Programmiersprache R ungemein, wenngleich auch schon im ersten Installationsschritt über das R Programm die gleichen Funktionsanwendungen ausführbar sind. So stellt RStudio vor allem eine Vereinfachung des Arbeitsprozesses dar, obgleich mit weitreichenden Implikationen bei der Nachvollziehbarkeit von Ablaufschritten und Anwendungsverfahren. 0.2 Warum R? R ist eine Programmiersprache, die speziell für statistische Berechnungen und Visualisierungen von Daten konzipiert ist. R ist eine der führenden Lösungen für die statistische Datenanalyse und kann auch für das Data Mining oder Predictive Analytics eingesetzt werden. Daten lassen sich mit der Sprache sehr flexibel auswerten und visualisieren. Sowohl wissenschaftliche Organisationen als auch große Unternehmen wie Oracle oder Microsoft verwenden R umfassend. R kann problemlos in alle Ebenen der Analyse und Präsentation von Daten integriert werden. Dank der Flexibilität von R ist der gleiche Code sowohl für kleinere Datenanalysen als auch für umfangreiches Data Mining im Big-Data-Umfeld geeignet. Die Plattformunabhängigkeit sorgt dafür, dass R in verschiedenste IT-Strukturen leicht integrierbar und universell nutzbar ist. Und zuletzt: Im Gegensatz zu anderen Lösungen für die Analyse und Visualisierung von Daten ist R Open Source. Es fallen keine Lizenzkosten an, auch nicht für den Großteil der verfügbaren Erweiterungspakete. 0.3 Was ist R? R wurde 1992 von Ross Ihaka und Robert Gentleman an der Universität Auckland entwickelt und wird als Open Source-Software unter der GNU General Public License durch die in Wien ansässige R Foundation for Statistical Computing verwaltet und verbreitet. R stammt direkt von der kommerziellen statistischen Programmiersprache S ab und während das Herz von R durch das R (Development) Core Team (aus dem auch die Stiftung hervorgegangen ist) weiterentwickelt wird, liegt die eigentliche Stärke von R in der Verfügbarkeit von Zusatzfunktionen, in Form sogenannter Packages (dt. Packete). So erweitern unabhängige Entwickler überall auf der Welt durch unzählige Packages mit unterschiedlichsten Ausrichtungen die Funktionsmöglichkeit von R, angefangen von der klassichen Regression bis zum maschinellen Lernen. Mehr als 12.000 dieser Funktionspakete, die geschätzt mehr als 220.000 Funktionen beinhalten, stehen über das Comprehensive R Archive Network (CRAN) und einige weitere Hubs zur kostenfreien Verfügung. Folglich gibt es praktisch kein statistisches Problem, dass noch nicht eine entsprechende Lösung in R gefunden hat und damit gebrauchsfertig heruntergeladen und nach eigenen Vorstellungen modifiziert werden kann. 0.4 Aller Einstieg ist schwer?! Wir werden uns primär mit R als Statistikumgebung und weniger als klassische Programmierumgebung beschäftigen, wenngleich kleinere Exkurse in die Fundamente dieser Sprache nicht vermieden werden können. Unser Anspruch bleibt dabei immer eine einfache, konsistente und übersichtliche Lösung zu geben, um dem freien und selbstbestimmten Lernen und Arbeiten aller Teilnehmenden Sorge zu tragen. Um diesem Anspruch gerecht werden zu können, werden wir uns vornehmlich in relativ “abgeschlossenen” Ökosystemen (Ecosystems) bewegen, also Sammlungen von Packeten, die aufeinander abgestimmt wurden. Das bekannteste Beispiel ist hierfür sicherlich das tidyverse, welches maßgebend von einem der großen R-Pioniere und RStudio chief scientist Hadley Wickham entwickelt wurde. Auf Grundlage des selbigen werden wir noch die Packete von Daniel Lüdecke strengejacke und die beeindruckenden Modellaufbereitungen in easystats kennen lernen. So repräsentieren diese Packete in vollem Umfang den “state-of-the-art” sozialwissenschaftlicher Datenanalysetechniken, obgleich der Lernprozess damit deutlich vereinfacht ist. Zudem werden alle genannten Packete, vor allem das tidyverse, auch in nicht-universitären Kontexten weitreichend genutzt. 0.5 Typographie Die folgenden Kapitel bestehen zu einem großen Teil aus R Code und damit aus den entsprechenden chunks. Damit können sie leicht erkannt und für den eigenen Gebrauch in das persönliche R Script kopiert werden. Ein Beispiel: x &lt;- seq(from = 1, to = 100, by = 10) x Das Ergebnis lässt sich folgend in der Konsole ablesen. ## [1] 1 11 21 31 41 51 61 71 81 91 Damit ist x unser Input und ## [1] 1 11 21 31 41 51 61 71 81 91 unser Output nachdem wir x eine Zahlensequenz zwischen 1 und 100 in 10er Schritten zugewiesen haben. 0.6 Weiterführende Literatur Wir orientieren uns vor allem in den ersten beiden Kapiteln unseres Workshops an dem Kurs: Einführung in R von Andrew Ellis und Boris Mayer. Grundständige Literatur, die auch zu diesem Workshop passt, findet sich als freie Publikation von Garrett Grolemund und Hadley Wickham unter dem Titel R for Data Science. Zur Vertiefung bieten sich die Bücher Hands-On Programming with R von Garrett Grolemund und Advanced R von Hadley Wickham an. "],["rstudio.html", "1 RStudio 1.1 Benutzeroberfläche 1.2 Optionen 1.3 Konsole 1.4 Environment und History 1.5 Files 1.6 Packages 1.7 Help 1.8 Arbeiten mit RStudio", " 1 RStudio In einem ersten Schritt wollen wir uns RStudio genauer ansehen. Öffnen Sie nun bitte RStudio. 1.1 Benutzeroberfläche Sie sollten ungefähr die gleiche Benutzeroberfläche bzw. GUI (Graphical User Interface) vor sich sehen (standardmäßig weiß): 1.2 Optionen Wir empfehlen eindrücklich vor Beginn einer intensiven Nutzung mit RStudio die folgenden Punkte in den Optionen unter Preferencesbzw. Global Options zu deaktivieren. Restore .RData into workspace at startup (deaktivieren) Save workspace to .RData on exit (Never) Folgend müssen wir immer alle Daten und Variablen bei einem Neustart von RStudio neu laden. Belohnt werden wir hingegen durch einen frischen Workspace. Sofern Sie Interesse an einer Änderungen der grafischen Darstellung von RStudio haben (z.B. eine dunkle Farbgebung), sollten Sie sich unter dem Menüpunkt Appearance ausprobieren. 1.3 Konsole Die R Konsole ist praktisch das Herzstück der Benutzeroberfläche und ermöglicht geschriebenen Code direkt oder über das R Script interpretieren zu lassen. Das &gt; Zeichen ist die R Prompt (das Aufforderungszeichen). Die Konsole kann gerne auch als Übungsfeld für die ersten Eingaben genutzt werden, z.B. als Taschenrechner. 2+3 ## [1] 5 1.4 Environment und History Im Reiter Enironment finden wir die Funktion Global Environment (drop-down menu). In diesem Bereich werden alle Objekte, also Variablen und Datensätze, die wir zuvor angelegt haben, gespeichert. Auch selbstgeschriebene Funktionen werden hier hinterlegt. Unter dem Reiter History finden Sie alle Befehle, die Sie bisher ausgeführt haben. Mit einem Doppelklick werden diese automatisch in die Konsole kopiert. Damit können sie einfach modifiziert und/oder erneut ausgebenen werden. Tipp: Die History lässt sich auch direkt über die Testenbefehle cmd+ up auf macOS bzw. strg+ up bei Windows in der Konsole abrufen. 1.5 Files Unter dem Reiter Files können Sie auf Ihre Datenstruktur zugreifen und damit ein Arbeitsverzeichnis (working directory) festlegen (siehe Bild). Die Festlegung eines Arbeitsverzeichnis erleichtert in Folge das Einlesen von weiteren Datenobjekten (z.B. Datensätzen), sofern nicht in einem Project gearbeitet wird. Das Arbeitsverzeichnis muss in dem Ordner gesetzt werden, indem sich auch der Datensatz bzw. die einzulesenden Daten befinden. 1.6 Packages R stellt uns über base R schon eine ganze Reihe nützlicher Funktionen zur Verfügung. Diese bewegen sich jedoch auf sehr abstarktem Niveau und würden bei ausschließlicher Nutzung viele Analyseschritte sehr aufwendig machen. Folgend greifen wir auf die versprochenen Packete bzw. Ökosysteme zurück, um unsere Funktionsbibliothek deutlich zu erweitern. Packete lassen sich mit dem folgenden Befehl in der Konsole sehr leicht installieren. install.packages(&quot;tidyverse&quot;) Damit haben wir alle Packete und Funktionen aus dem tidyverse installiert. Nun wollen wir noch strengejacke und easystats installieren. Die Packete aus strengejacke können entweder einzeln über das CRAN installiert werden, oder im Bündel über Github. Wollen wir z.B. nur das Packet sjmisc aus strengejacke installieren verwenden wir den folgenden Befehl: install.packages(&quot;sjmisc&quot;) Sofern das ganze Bündel installiert werden soll, laden wir zunächst das Packet remotes, um Github als Downloadplattform anwählen zu können und dann strengejacke. install.packages(&quot;remotes&quot;) remotes::install_github(&quot;strengejacke/strengejacke&quot;) Damit wurde strengejacke erfolgreich installiert! Das Ökosystem easystats ist gegenwärtig noch in der Testphase und damit auch nur über Github zu laden. install.packages(&quot;remotes&quot;) remotes::install_github(&quot;easystats/easystats&quot;) Gratulation, damit haben wir die wichtigsten Packete installiert! Nun müssen wir sie nur noch aktivieren. Dafür nutzen wir den Befehl library, um auf unsere Funktionsbibliothek zuzugreifen. library(tidyverse) library(strengejacke) library(&quot;easystats&quot;) Wichtig! Das Packetbündel easystats muss beim Aufruf in Anführungszeichen geschrieben werden. Als Alternative können wir Packete auch über den Reiter Packages installieren und aktivieren (oben links im Fenster). Updates lassen sich über den Reiter Packages oder den folgenden Befehl machen: update.packages() bzw. update.pachakes(ask = F) 1.7 Help Selbst wenn man täglich mit R arbeitet, ist es (fast) unmöglich, sich alle Funktionen zu merken. Deshalb bietet R über den Reiter Help die Möglichkeit eine lexikale Darstellung aller Funktionen und Anwendungsmöglichkeiten zu bekommen. Leider sind viele der Einträge zu Beginn nicht ganz leicht verständlich. Nach einiger Zeit bieten sie aber eine zuverlässige Möglichkeit neue Funktionen zu erlenen und alte nachzuschlagen. Hat man eine Funktion im Kopf lässt sich diese leicht über das Suchfenster im Help Viewer suchen. Über die Konsole geht das natürlich auch. Der Befehl hier z.B. für den gewichteten Mittelwert: ?weighted_mean Hier muss nur die gesuchte Funktion hinter ein ? geschrieben werden. Will man herausfinden, welche Funktionen in einem Packet enthalten sind, ist der Reiter Packages zu öffnen. Über das Suchfenster das entsprechende Packet suchen und mit einem Klick öffnen. Anschließend wird man im Help Viewer über die möglichen Funktionen in einer Auswahl informiert. Viele Entwickler erstellen zudem eigene Websites für ihre Packages. Hier einige Beispiele: Auf der Seite des tidyverse das gewünschte Packet aussuchen und dann über Reference eine Auswahlliste der Funktionen aufrufen. Beim Klick auf eine Funktion wird die dahinterliegende Vignette - Erklärung mit Beispielen - geöffnet. Die Packete von strengejacke haben keine gebündelte Auswahl. Wir müssen uns also zuerst eines der Packete aussuchen (sjmisc, sjlabelled, sjplot, sjstats) und dann nach diesem suchen. Bei strengejacke lassen sich alle Packete über den folgenden Link öffnen: https://strengejacke.github.io/*Packetname*/, also z.B. https://strengejacke.github.io/sjmisc/ Bei den Packeten von easystats gilt das genauso. Erst ein Packet wählen (parameters, performance, effectsize, correlation, see) und dann öffnen über: https://easystats.github.io/*Packetname*/ Tipp: Um einen erster Eindruck über die Anwendungsmöglichkeiten und die Form der Packete zu bekommen, lohnt sich zudem der Klick auf den Reiter Articles auf den Dokumentationsseiten der Packete! Abschließend ist noch die FAQ-Seite Stackoverflow zu empfehlen, auf der schier zu jedem Problem schon einmal eine Frage gestellt und diese beantwortet wurde. Hierzu lohnt es sich das eigene Problem mit dem zusätzlichen Schlagwort Stackoverflow in eine Suchmaschine zu geben und die Einträge nach Lösungen zu durchsuchen. 1.8 Arbeiten mit RStudio Auf an die praktische Arbeit mit RStudio! 1.8.1 Projects Vor der eigentlichen Arbeit mit R und der Analyse von Daten ist es immer ratsam über die Erstellung eines Projekts nachzudenken. Über den Menüpunkt File + New Project + New Directory + New Project öffnet sich die entsprechende Auswahlmaske. Hier kann ein Projektname und der gewünschte Speicherort festgelegt werden. Im nächsten Schritt schieben wir die gewünschten Datensätze in den Projektordner, um einen ungehinderten Datenzugriff zu ermöglichen. Vorteile: Alle Files werden beim Start des Projekts, über den blauen Projektwürfel (.Rproj), wieder geöffnet. Es lassen sich beliebig viele Projekte gleichzeitig öffnen und zwischen diesen wechseln. Bei der Erstellung eines Projekts wird automatisch ein Arbeitsverzeichnis erstellt, auf das zurückgegriffen wird (Projektordner). Man muss sich also nicht mehr um das working directory bemühen und kann z.B. Daten- oder Skriptdateien direkt vom Projektordner aus aufrufen, ohne jedes Mal den vollständigen Pfad definieren zu müssen. 1.8.2 Konsole oder RScript? Es stehen dem Benutzer von RStudio wesentlich zwei Nutzungswege zur Verfügung: 1. Befehle direkt über die Konsole eintippen Die Eingabe über die Konsole ist dann empfehlenswert, wenn man schnell etwas ausprobieren möchte, oder ein Befehl wiederholt werden soll. Die Konsole wird auch bei unvollständiger Eingabe von Funktionen relevant. Im folgenden Beispiel wurde eine Klammer am Ende der Funktion vergessen. &gt; seq(1, 100, 5 + Nun muss entweder die fehlende Klammer zur Vervollständigung eingetippt, oder über Escder Befehl abgebrochen werden. Wird ein Befehl ungewollt ausgeführt, oder ist R abgestürzt? Hier kann ganz leicht über Session + Interrupt R bzw. das rote Stoppschild über der Konsole der Befehl abgebrochen, oder die ganze Sitzung über Session + Terminate R neu gestartet werden. 2. Befehle im Script speichern (vergleichbar mit Syntax aus SPSS) Zur Erstellung eines RScript öffnen wir über das Symbol mit dem weißen Blatt und grünem Kreuz (oben links) ein neues RScript (Tastenkürzel: cmd bzw. strg + up + N). Vorteile sind hier, wie auch in SPSS, die Möglichkeit zur übersichtlichen und nachvollziehbaren Arbeitsweise und das Speichern von Auswertungen. Wichtig! RScript-Datein werden beim Ausführen von oben nach unten gelesen. Wir können also Werte im Laufe eines Scripts immer wieder überschreiben und neu zuweisen. Wir probieren uns zu Beginn wieder an einer kurzen Rechnung aus. 2+3 Um die entsprechende Zeile auszuführen, klicken wir auf Run (Tastenkürzel: cmd bzw. strg + enter). ## [1] 5 Der Output erscheint wie gewohnt in der Konsole. Im nächsten Schritt definieren wir das Ergebnis unserer mathematischen Operation als Variable (Objekt), um es für folgende Anwendungen nutzen zu können. var1 &lt;- 2+3 Damit haben wir unsere gewünschte Variable (Objekt) mit der Bezeichnung var1 definiert. Wichtig ist für uns erstmal, dass wir unsere definierten Variablen im Environment sehen können. var1 wird folgend mit dem Wert 5 angezeigt. 1.8.3 Tab completion RStudio verfügt über eine weitere sehr hilfreiche Funktion: Tab completion. Während der Eingabe eines beliebigen Befehls erscheint über RStudio ein entsprechendes Menu mit Befehlsvorschlägen zur Vervollständigung. So erscheint z.B. bei der Eingabe von weighted_mean() eine ganze Reihe von Vorschlägen. Manuell wird auch über Tab das gleiche Menu aufgerufen. Wollen wir die erste Funktion übernehmen, drücken wir Enter zur Bestätigung. Zur Auswahl einer anderen Funktion einfach über die Pfeiltasten die richtige Funktion ansteuern und diese über Enter anwählen. Hat man eine Funktion eingegeben und drückt man innerhalb der Klammern Tab, erscheint eine Liste mit allen Argumenten dieser Funktion. Funktionsargumente definieren welche Daten einbezogen werden sollen und wie mit diesen umgegangen wird. x = steht z.B. für die eingehenden Daten und weights = für das anzuwendende Gewicht. Überschneiden sich zwei Funktionensbezeichungen zwischen zwei Packeten oder wissen wir, dass eine Funktion in einem Packet enthalten ist, können wir auch über den Packetnamen gefolgt von :: eine Funktionsliste erzeugen. 1.8.4 Nützliche Tastenbefehle (Shortcuts) Folgende Tastenbefehle erleichtern das Arbeiten mit R. Befehl Wirkung Wir haben schon folgende Befehle kennen gelernt: cmd bzw. strg + up Vorherige Befehle in der Konsole anzeigen cmd bzw. strg + up + N Neues Script erstellen cmd bzw. strg + Enter Eingabe ausführen cmd bzw. strg + S Speichert geöffnete RScript-Datei cmd bzw. strg + option + S Speichert alle geöffneten RScript-Datein Weitere nützliche Befehle: cmd bzw. strg + up + Enter Gesamtes Script ausführen cmd bzw. strg + up + R Kapitel im RScript definieren cmd bzw. strg + up + C Kommentar im RScript control bzw. strg + L Konsole leeren cmd bzw. strg + up + A Code restrukturieren Für folgende Kapitel: option + - Zuweisungspfeil (&lt;-) erzeugen cmd bzw. strg + up + M %&lt;% erstellen Tipp: Um alle verfügbaren Tastenkürzel in RStudio sehen zu können, drücken Sie: option bzw. strg + up + K. "],["programmiersprache-r.html", "2 Programmiersprache R 2.1 Variablen definieren 2.2 Funktionen aufrufen 2.3 Objekte und Datentypen 2.4 Pipe Operatoren", " 2 Programmiersprache R In diesem Kapitel wollen wir R als Programmierspache kennenlernen. 2.1 Variablen definieren In einem ersten Schritt wollen wir eine Rechnung (einen Wert) in einer Variable speichern. var1 &lt;- 2*4 Unsere Variable mit dem Namen x (immer links in der Zeile) wird über den Zuweisungspfeil &lt;- (Tastenkürzel: option + -) mit dem Ergebnis aus 2*4 (8) definiert. Zur Kontrolle können wir x mit den folgenden Befehlen aufrufen. var1 #&gt; [1] 8 Man kann auch gleich bei der Definition der Variablen die Zuweisung in Klammern schreiben und das Resultat wird gleichzeitig in der Konsole angezeigt. (var1 &lt;- 2*4) #&gt; [1] 8 Tipp: Sollten Sie aus anderen Programmiersprachen schon Kenntnisse mitbringen und = als Zuweisungsoperator kennen, empfehlen wir dennoch eindringlich mit &lt;- zu arbeiten. Funktionen in R arbeiten bei der Zuweisung von Argumenten mit dem Zuweisungsoperator =. Folglich ist die Verwendung von &lt;- nicht nur besser zu lesen, sie kann auch Fehler vorbeugen. 2.1.1 Variablennamen Eine Variable muss immer einen Namen haben. Sie darf aus Buchstaben, Zahlen und den Zeichen . und _ bestehen. Dennoch muss sie immer mit einem Buchstaben beginnen und darf keine Leerzeichen enthalten. Um lesbaren und verständlichen Code zu schreiben, gibt es ein paar Konventionen an die man sich halten sollte. Hier gibt es zwei gängige Möglichkeiten und eine ältere Form, um Variablen zu bennen. Die Wahl ist egal, solange man konsequent bei einer Schreibweise bleibt! 1. snake_case_variable Bei dieser Schreibform werden die einzelnen Worten in einer Variablenbezeichnung durch Unterstriche verbunden und alle Worte kleingeschrieben. 2. camelCaseVariable Hier wird nur das erste Wort kleingeschrieben und die folgenden mit dem ersten Buchstaben großgeschrieben. 3. variable.with.perdiods (alt) Die kleingeschriebenen Worte werden mit Punkten getrennt. # Gute Bezeichnungen efaKonstrukt1 efa_konstrukt_1 # Schlechte Bezeichnungen Efa.konstrukt_1 efaKonstrukt_1 # Unmöglich efa 1 2.2 Funktionen aufrufen “Everything that exists is an object. Everything that happens is a function call.” –John Chambers Objekte haben wir schon in ihrer einfachsten Form als Rechenergebnis in einer Variable kennengelernt. Um kompliziertere Objekte verstehen zu können, wollen wir uns erst den Funktionen (function calls) in R zuwenden. Unsere Funktion sieht wie folgt aus (ein fiktionales Beispiel): functionName(arg1 = Daten, arg2 = option1, arg3) In einem ersten Schritt sehen wir uns an, welchen Namen die Funktion trägt. Unsere Funktion heißt functionName. Wir können leider nicht direkt aus dem Namen erschließen, welche Auswirkung unser function call haben wird. In so einem Fall würde ein Blick in Help (?functionName) sicher Abhilfe schaffen, wenngleich wir in unserem Beispiel leider keine Dokumentation nutzen können. So sehen wir uns in einem zweiten Schritt die Argumente unserer Funktion an. Wie wir sehen können, besitzt unsere Funktion drei Argumente: arg1, arg2 und arg3. Die Argumente werden mit spezifischen Werten über = bestückt. In unserem Beispiel benötigt das erste Argument Daten und das zweite Argument einen spezifischen Wert aus einer Auswahl an möglichen Werten - diese werden immer vom Entwickler der Funktion in der Dokumentation angegeben. Das dritte Argument wird als “default” abgerufen, also über eine Voreinstellung der Entwicklers geladen. Argumente die mit “default” arbeiten sind aber keinesfalls fest. Sie können immer auch durch andere Werte ersetzt werden. Argumente arbeiten immer dann mit “default,” wenn die Grundeinstellung des Arguments die häufigste Nutzungsform darstellt und man nicht bei jedem function call die Wertzuweisung von neuem schaffen möchte. Tipp: Wollen wir alle verfügbaren Argumente in einer Funktion sehen, drücken wir Tab. Wichtig! Eine Funktion kann beliebig viele Argumente besitzen. Um uns einer “großen” Funktion zu nähern, müssen wir zu Beginn einige “Grundfunktionen” kennenlernen. c() &gt; Combine: kreiert einen Vektor seq(from, to, by) &gt; Generiert eine Sequenz an Zahlen : &gt; Colon Operator: generiert eine reguläre Sequenz (Sequenz in Einerschritten) rep(x, times, each) &gt; Wiederholt x times: Sequenz wird n-mal wiederholt each: jedes Element wird n-mal wiederholt head(x, n = 6) &gt; Zeigt die n ersten Elemente von x an tail(x, n = 6) &gt; Zeigt die n letzten Elemente von x an print(x) &gt; Gibt Werte eines Objekts aus (vor allem bei großen Objekten wichtig) round(x, digits) &gt; Rundung von Zahlen z.B. # Daten erzeugen # Vektor erzeugen c(1, 2, 3, 4, 5) #&gt; [1] 1 2 3 4 5 # Sequenz erzeugen seq(from = 1, to = 10, by = 2) #&gt; [1] 1 3 5 7 9 # Reguläre Sequenz erzeugen 1:5 #&gt; [1] 1 2 3 4 5 # Wiederholt 2 ganze 3-mal in 5 Schleifen rep(x = 2, times = 5, each = 3) #&gt; [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 # Überblick über die erzeugten Daten # Vektor in var1 speichern var1 &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) # Ersten 6 Elemente in var1 head(x = var1, n = 6) #&gt; [1] 1 2 3 4 5 6 # Letzten 4 Elemente in var1 tail(x = var1, n = 4) #&gt; [1] 7 8 9 10 # Alle Elemente in var1 print(x = var1) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 # Daten transformieren var2 &lt;- c(1.222, 2.333, 3.444) # var2 wird auf eine Nachkommastelle gerundet round(x = var2, digits = 1) #&gt; [1] 1.2 2.3 3.4 Wir wollen uns die Variable y etwas genauer ansehen. y enthält durch das Aufrufen der Funktion c() eine Reihe von Zahlen (1.222 bis 3.444) mit drei Nachkommastellen. Diese Zahlen wollen wir mit der Funktion round() auf eine Nachkommastelle runden. Das Argument digits beschreibt damit die Rundungszahl nach dem Komma. digits = 1 löst eine Rundung der Nachkommastellen auf die erste Nachkommastelle aus. Der Wert im Argument digits kann damit theoretisch von 0 bis ∞ variieren. 2.2.1 Verschachtelung von Funktionen Zudem können wir beliebig viele Funktion ineinander verschachteln, d.h. wir können den Output einer Funktion einer anderen Funktion als Input übergeben. Wir bilden zuerst einen Vektor, runden die Zahlen und lassen uns dann nur die ersten drei Zahlen ausgeben. # Mehrere Funktionen hintereinander var1 &lt;- c(1.11, 1.22, 1.33, 1.44, 1.55) var1 &lt;- round(x = var1, digits = 1) head(x = var1, n = 3) #&gt; [1] 1.1 1.2 1.3 # jetzt in einer verschachtelten Funktion head(x = round(x = c(1.11, 1.22, 1.33, 1.44, 1.55), digits = 1), n = 3) #&gt; [1] 1.1 1.2 1.3 # kürzeste Form head(round(c(1.11, 1.22, 1.33, 1.44, 1.55), digits = 1), n = 3) #&gt; [1] 1.1 1.2 1.3 # Mit var1 als Dateninput head(round(var1, digits = 1), n = 3) #&gt; [1] 1.1 1.2 1.3 Die Funktionen werden immer in Reihenfolge von innen nach außen ausgeführt. In unserem Beispiel also erst c(), dann round() und dann head(). Jede Funktion gibt ihren Wert an die nächste Funktion weiter. Anmerkung: Die Funktion head() enthält zwei Argumente mit “default”-Werten: keepnums und addrownums. Beide bekommen automatisch (“default”) den Wert NULL und müssen damit nicht ausgeschrieben werden. Sie werden für unsere Anwendung auch nicht gebraucht und damit nicht angepasst. Vorteile von verschachtelten Funktionen: Es können unendlich viele Funktionen verschachtelt werden. Wir müssen Argumente nicht ausschreiben, solange sie eindeutig von der Funktion erkannt werden können. So gibt es in allen genutzten Funktionen mit x = nur eine Schnittstelle für die Dateneingabe. Weiterhin können wir so unseren Code in eine Kette von Befehlen verwandeln, die nur einen Output (ein Objekt) ausgibt. Die Objektstruktur wird damit übersichtlicher. Nachteil: Wenn wir mehrere Funktionen ineinander verschachteln, kann unser Code schnell unlesbar werden. Natürlich könnten wir die einzelnen Zwischenschritte speichern, wie im Beispiel weiter oben, aber dann definieren wir eine Menge Variablen, welche wir vielleicht gar nicht benötigen. Wir werden im Kapitel über Datentransformation einen neuen Operator kennenlernen, welcher eine sehr elegante Lösung für dieses Problem bietet. 2.3 Objekte und Datentypen In R kann alles als Objekt in Variablen gespeichert werden. Einzelne Werte / Mehrere Werte (z.B. ein Datensatz mit Rohdaten) Tabellen Statistische Modelle Ergebnisse statitischer Analysen Funktionen, etc. Anmerkung: Objekte sind nicht gleich Variablen, da Objekte nicht gespeichert werden müssen. Ein Objekt wird erst dann zur Variable, wenn es eine Bezeichnung über &lt;- erhält und damit gespeichert wird. Die Zahlenfolge aus c(1, 2, 3) stellt auch schon ein Objekt da. In R gibt es eine Vielzahl von verschiedenen Objekttypen. Die grundlegenden Objekttypen sind: 2.3.1 Vektoren (vector) Vektoren → ordinale/metrische Variablen numeric (Zahlen) character (Buchstaben) logical (Richtig oder Falsch) Beispiel # Numerischer Verktor (numeric vector) var1 &lt;- c(1, 2, 3, 4, 5) var1 #&gt; [1] 1 2 3 4 5 # Buchstaben Vektor (character vector) var2 &lt;- c(&quot;Peter&quot;, &quot;Yusuf&quot;, &quot;Sarah&quot;, &quot;Aayana&quot;) var2 #&gt; [1] &quot;Peter&quot; &quot;Yusuf&quot; &quot;Sarah&quot; &quot;Aayana&quot; # Logischer Vektor (logical vector) var3 &lt;- c(TRUE, FALSE, NA) var3 #&gt; [1] TRUE FALSE NA Tipp: TRUE bzw. FALSE können mit T bzw. F abgekürzt werden. Vektoren stellen die fundamentalen Datentypen dar. Alle weiteren Datentypen bauen auf diesen auf. Zudem müssen Vektoren aus denselben Elementen bestehen, d.h. wir können keine logical und character Elemente in einem Vektor mischen. Sie bilden damit die atomare Struktur in R. numeric vector: Die häufigste Datenform in R. Numerische Vektoren lassen sich zudem weiter unterteilen, in integer (ganze Zahlen) und double (reele Zahlen - Kommazahlen). Zahlen werden in R praktisch immer als double abgelegt (auch die ganzen Zahlen) und müssen somit nie für Berechungen gewandelt werden. character vector: Die Elemente dieses Typs bestehen aus Zeichen, welche von Anführungszeichen umgeben werden (entweder ’ oder \" ). Sie werden auch strings genannt. Anmerkung: Anführungszeichen dienen in R zur Kennzeichnung von nicht numerischen Werten. Wir müssen also alle natürlichen Worte in jedem Kontext in Anführungszeichen schreiben. logical vector: Die Elemente dieses Typs können nur 3 Werte annehmen:TRUE, FALSE oder NA. Logische Vektoren lassen sich auch numerisch übersetzen in TRUE = 1 und FALSE = 0, damit werden sie auch als integer abgelegt. Das wird vor allem bei der Datenselektion relevant. Anmerkung: NA steht für fehlende Werte. Vektoren haben folgend drei Eigenschaften: # Modus bzw. Struktur (mode) - Was ist es? typeof(var1) #&gt; [1] &quot;double&quot; # Länge - Wie viele Elemente? length(var1) #&gt; [1] 5 # Attribute (optional) - Zusätzliche Informationen (Metadaten) attributes(var1) # x wurden noch keine attribute zugeordnet #&gt; NULL # ------ Zusatz ------ # Objektbestimmung class(var1) #&gt; [1] &quot;numeric&quot; Nun wollen wir auf die einzelnen Elemente in den Vektoren zugreifen (indizieren). Wir können die einzelnen Elemente eines Vektor mit [] anwählen (subsetting). zahlenreihe &lt;- c(1, 2.5, 3, 4, 5.77, 6, 7) # Das erste Element zahlenreihe[1] #&gt; [1] 1 # das fünfte Element zahlenreihe[5] #&gt; [1] 5.77 # Das letzte Element zahlenreihe[length(zahlenreihe)] #&gt; [1] 7 # Mit - (Minus) können wir gezielt Elemente ausschließen zahlenreihe[-4] #&gt; [1] 1.00 2.50 3.00 5.77 6.00 7.00 # Wir können auch Sequenzen auswählen zahlenreihe[2:5] #&gt; [1] 2.50 3.00 4.00 5.77 # Wir können auch gezielt mehrere Elemente ausschließen oder auswählen zahlenreihe[-c(1, 4)] #&gt; [1] 2.50 3.00 5.77 6.00 7.00 zahlenreihe[c(1, 2, 5)] #&gt; [1] 1.00 2.50 5.77 # Das Gleiche funktioniert auch mit einem character vector buchstabenreihe &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;) buchstabenreihe[1] #&gt; [1] &quot;A&quot; 2.3.2 Faktoren (factor) Faktoren → nominale/ordinale Variablen nominale Variable Kategorien des Faktors = levels (kann Zahlen oder Buchstaben enthalten) Bisher haben wir numeric, character und logical Vektoren kennengelernt. Ein weiterer Objekttyp wird benötigt, um kategoriale Daten oder Gruppierungsvariablen darzustellen. Dieser Objekttyp wird factor genannt. Ein Faktor ist ein Vektor mit ganze Zahlen (integer), welcher eine Beschriftung für die einzelnen Fakttorstufen (levels) besitzt. Die Beschriftungen sind letztlich Attribute (attributes), die Informationen über die Faktorstufen geben. Ein Beispiel: # Geschlecht als character vector sex &lt;- c(&quot;Mann&quot;, &quot;Frau&quot;, &quot;Mann&quot;, &quot;Frau&quot;, &quot;Frau&quot;, &quot;Div&quot;) sex #&gt; [1] &quot;Mann&quot; &quot;Frau&quot; &quot;Mann&quot; &quot;Frau&quot; &quot;Frau&quot; &quot;Div&quot; # Modus (mode) typeof(sex) #&gt; [1] &quot;character&quot; # Attribute attributes(sex) #&gt; NULL Nun haben wir einen character vector mit Informationen über Geschlechter. In einem nächsten Schritt wollen wir diesen Vektor als Faktor definieren. # Geschlecht als Faktor sexf &lt;- factor(sex, levels = c(&quot;Mann&quot;, &quot;Frau&quot;, &quot;Div&quot;)) sexf #&gt; [1] Mann Frau Mann Frau Frau Div #&gt; Levels: Mann Frau Div # Geschlecht hat nun den Datentyp integer typeof(sexf) #&gt; [1] &quot;integer&quot; # und die Klasse &quot;factor&quot; class(sexf) #&gt; [1] &quot;factor&quot; # jetzt sind auch die Attribute definiert attributes(sexf) #&gt; $levels #&gt; [1] &quot;Mann&quot; &quot;Frau&quot; &quot;Div&quot; #&gt; #&gt; $class #&gt; [1] &quot;factor&quot; Wir haben bei der Definition die levels explizit angegeben. Das hätten wir aber nicht machen müssen. R ordnet standardmäßig alle Faktorstufen alphabetisch zu. # Geschlecht als Faktor sexf2 &lt;- factor(sex) sexf2 #&gt; [1] Mann Frau Mann Frau Frau Div #&gt; Levels: Div Frau Mann # Datentyp typeof(sexf2) #&gt; [1] &quot;integer&quot; # Klasse class(sexf2) #&gt; [1] &quot;factor&quot; # Attribute attributes(sexf2) #&gt; $levels #&gt; [1] &quot;Div&quot; &quot;Frau&quot; &quot;Mann&quot; #&gt; #&gt; $class #&gt; [1] &quot;factor&quot; Wir werden Faktoren später häufig bei der Modellierung benötigen z.B. bei Regressionsmodellen mit Dummyvariablen. Die erste Stufe eines Faktors wird von R automatisch als Referenzkategorie bestimmt, wenn wir den Faktor als Prädiktorvariable in ein Modell einbringen. Manchmal wollen wir jedoch eine andere Stufe als Referenzkategorie. In diesem Fall kann man die Reihenfolge der Faktorstufen ändern. Über relevel() kann direkt die Refrenzkategorie bestimmt werden. # Unsere Refrenzkategorie ist gegenwärtig &quot;Mann&quot; levels(sexf) #&gt; [1] &quot;Mann&quot; &quot;Frau&quot; &quot;Div&quot; # Wir ändern die Refrenkategorie folgend auf &quot;Frau&quot; sexf &lt;- relevel(sexf, ref = &quot;Frau&quot;) levels(sexf) #&gt; [1] &quot;Frau&quot; &quot;Mann&quot; &quot;Div&quot; Mit der Funktion factor() lassen sich alle Faktorstufen frei ordnen, solange wir im Befehl alle Faktorstufen benutzen. Die erste Stufe wird folglich zur Refrenzkategorie. # Unsere Refrenzkategorie ist gegenwärtig &quot;Frau&quot; levels(sexf) #&gt; [1] &quot;Frau&quot; &quot;Mann&quot; &quot;Div&quot; # Wir ändern die Refrenkategorie durch die neue Auflistung unserer level auf &quot;Mann&quot; sexf &lt;- factor(sexf, levels = c(&quot;Mann&quot;, &quot;Frau&quot;, &quot;Div&quot;)) levels(sexf) #&gt; [1] &quot;Mann&quot; &quot;Frau&quot; &quot;Div&quot; Durch die Festlegung einer Variable als Faktor wird diese automatisch dummykodiert und kann umstandslos in ein Modell einbezogen werden. Wir müssen nur die Refrenzkategorie im Blick behalten. 2.3.3 Datensatz (data frame) Datensatz (mehrere Zeilen und Spalten) Spalten (Vektoren und Faktoren) Zeilen (Fälle, z. B. Versuchspersonen) Nun kommen wir zu dem für uns wichtigsten Objekt in R, dem Datensatz. Ein Datensatz besteht aus Zeilen (rows) und Spalten (columns) gleicher Länge und entspricht einem Datensatz in SPSS. Die Spalten eines Datensatz sind lediglich Vektoren. Sie können damit numeric, character und logical sein, oder als factor auftreten. Numerische Variablen in einem Datensatz sollten demzufolge numerische Vektoren und kategoriale Variablen/Gruppierungsvariablen sollten Faktoren sein. Durch die Mischung von Datentypen innerhalb des Objekts “Datensatz” sprechen wir auch von einer rekursiven Struktur. Datensätze werden traditionell über die Funktion data.frame() definiert. Da wir das tidyverse nutzen, greifen wir auf eine weiterentwickelte Form zurück - tibbles oder tbl. tibbles werden über die Funktion tibble() definiert und erleichtern so die Arbeit mit dem Datensatz. Anmerkung: Der Vorteil liegt beim Einlesen von Datensätzen, da weniger Rücksicht auf die Datenstruktur genommen werden muss. Durch tibbles wird viel durch R automatisiert. Erstellung eines Datensatz. # Vektoren sex &lt;- factor(c(&quot;Mann&quot;, &quot;Frau&quot;, &quot;Mann&quot;, &quot;Mann&quot;, &quot;Frau&quot;, &quot;Mann&quot;)) alter &lt;- c(22, 45, 67, 87, 16, 56) # Datensatz datensatz &lt;- tibble(sex, alter) datensatz #&gt; # A tibble: 6 x 2 #&gt; sex alter #&gt; &lt;fct&gt; &lt;dbl&gt; #&gt; 1 Mann 22 #&gt; 2 Frau 45 #&gt; 3 Mann 67 #&gt; 4 Mann 87 #&gt; 5 Frau 16 #&gt; 6 Mann 56 Unser datensatz ist damit ein Datensatz mit zwei Variablen (sex und alter) und sechs Fällen (rows). Dieser wird uns entsprechend im Environment angezeigt. Ein Datensatz hat die Attribute names(), colnames() und rownames() - [names() und colnames() bedeuten dasselbe]. attributes(datensatz) #&gt; $names #&gt; [1] &quot;sex&quot; &quot;alter&quot; #&gt; #&gt; $row.names #&gt; [1] 1 2 3 4 5 6 #&gt; #&gt; $class #&gt; [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Wir können zudem sowohl die Länge des Spaltenvektors (Anzahl der Spalten) über ncol abfragen, wie auch die Länge des Zeilenvektors (Anzahl der Fälle) über nrow. ncol(datensatz) #&gt; [1] 2 nrow(datensatz) #&gt; [1] 6 2.3.3.1 Datensatz indizieren (subsetting) Ein Datensatz ist eine 2-dimensionale Struktur aus Spalten und Fällen, die entsprechend indiziert werden kann. Einzelne Spalten können über $ ausgewählt werden. Einzelne oder mehrere Elemente, ob Spalten oder Zeilen, können über [] ausgewählt werden. # Spaltenname zur Auswahl einer spezifischen Variable über $ datensatz$sex #&gt; [1] Mann Frau Mann Mann Frau Mann #&gt; Levels: Frau Mann # Spaltenname zur Auswahl einer spezifischen Variable über [] datensatz[&quot;sex&quot;] #&gt; # A tibble: 6 x 1 #&gt; sex #&gt; &lt;fct&gt; #&gt; 1 Mann #&gt; 2 Frau #&gt; 3 Mann #&gt; 4 Mann #&gt; 5 Frau #&gt; 6 Mann # Nach Position auswählen datensatz[2] #&gt; # A tibble: 6 x 1 #&gt; alter #&gt; &lt;dbl&gt; #&gt; 1 22 #&gt; 2 45 #&gt; 3 67 #&gt; 4 87 #&gt; 5 16 #&gt; 6 56 Wir können aber auch mehrer Variablen und sogar Zeilen (Fälle) auswählen. Sobald wir die Werte in [] durch ein Komma trennen, gibt der erste Wert die Zeilen und der zweite die Spalten an. Ohne Komma nur die Spalten. # Erste Spalte und erste Zeile datensatz[1, 1] #&gt; # A tibble: 1 x 1 #&gt; sex #&gt; &lt;fct&gt; #&gt; 1 Mann # Erster Fall über alle Spalten (Variablen) datensatz[1, ] #&gt; # A tibble: 1 x 2 #&gt; sex alter #&gt; &lt;fct&gt; &lt;dbl&gt; #&gt; 1 Mann 22 # Alle Zeilen in der ersten Spalte datensatz[, 1] #&gt; # A tibble: 6 x 1 #&gt; sex #&gt; &lt;fct&gt; #&gt; 1 Mann #&gt; 2 Frau #&gt; 3 Mann #&gt; 4 Mann #&gt; 5 Frau #&gt; 6 Mann # Wir können auch Sequenzen benutzen # Ersten drei Fälle über alle Spalten datensatz[1:3, ] #&gt; # A tibble: 3 x 2 #&gt; sex alter #&gt; &lt;fct&gt; &lt;dbl&gt; #&gt; 1 Mann 22 #&gt; 2 Frau 45 #&gt; 3 Mann 67 # Da die Spalten Vektoren sind, können wir diese genauso indizieren # Erster Fall im Vektor zu Geschlecht datensatz$sex[1] #&gt; [1] Mann #&gt; Levels: Frau Mann # Letzten drei Fälle in der Variable alter datensatz$alter[4:length(datensatz$alter)] #&gt; [1] 87 16 56 # Die Spalten sex und alter datensatz[c(&quot;sex&quot;, &quot;alter&quot;)] #&gt; # A tibble: 6 x 2 #&gt; sex alter #&gt; &lt;fct&gt; &lt;dbl&gt; #&gt; 1 Mann 22 #&gt; 2 Frau 45 #&gt; 3 Mann 67 #&gt; 4 Mann 87 #&gt; 5 Frau 16 #&gt; 6 Mann 56 2.3.4 Listen (list) Listen → in SPSS nicht vorhanden Kombination mehrerer Objekte Listen können beliebige Objekte enthalten, auch Objekte verschiedenen Typs. Im Unterschied zu Datensätzen können auch Objekte unterschiedlicher Länge gespeichert werden. Ein weiterer Datentyp ist list. Während Datensätze schon aus verschiedenen Vektoren bestehen können, lassen sich diese in Listen auch in verschiedenen Längen ablegen. Die meisten Objekte die wir im Verlauf unserer R Anwendung kennenlernen werden, sind damit Listen (z.B. die Ergebnisse eines Regressionsmodells werden als Liste gespeichert). Wir müssen aber nur mit ihnen umgehen können und sie verstehen. Wir werden sie praktisch nie selbst erstellen müssen. In einem ersten Schritt wollen wir dennoch mit der Funktion list() eine Liste definieren. So können wir schrittweise verstehen, welche Eigenschaften Listen besitzen. list1 &lt;- list(1:3, &quot;a&quot;, c(1.22, 2, 3.44, 4, 5), c(TRUE, FALSE, FALSE)) list1 #&gt; [[1]] #&gt; [1] 1 2 3 #&gt; #&gt; [[2]] #&gt; [1] &quot;a&quot; #&gt; #&gt; [[3]] #&gt; [1] 1.22 2.00 3.44 4.00 5.00 #&gt; #&gt; [[4]] #&gt; [1] TRUE FALSE FALSE Wir haben mit der Variable list1 eine Liste erstellt, die als Elemente einen numeric Vektor mit einer Zahlenreihe, einen character Vektor mit der Länge 1 (L1), einen numericVektor mit Kommazahlen und einen logical Vektor speichert. Listen können wie Vektoren indiziert werden. # Erstes Element in der Liste (erster Vektor) list1[1] #&gt; [[1]] #&gt; [1] 1 2 3 # Zweites Element (zweiter Vektor) list1[2] #&gt; [[1]] #&gt; [1] &quot;a&quot; # Drittes Element (dritter Vektor) list1[3] #&gt; [[1]] #&gt; [1] 1.22 2.00 3.44 4.00 5.00 Häufig sind die Elemente in einer Liste als Variablen benannt und können entsprechend wie in einem Datensatz über $ abgerufen werden. list2 &lt;- list(var1 = c(1, 2, 3), var2 = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;), var3 = c(TRUE, FALSE), var4 = seq(from = 1, to = 100, by = 5)) # Ganze Liste abrufen list2 #&gt; $var1 #&gt; [1] 1 2 3 #&gt; #&gt; $var2 #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; #&gt; #&gt; $var3 #&gt; [1] TRUE FALSE #&gt; #&gt; $var4 #&gt; [1] 1 6 11 16 21 26 31 36 41 46 51 56 61 66 71 76 81 86 91 96 # Aufruf der ersten Variable mit ihrem Namen var1 list2$var1 #&gt; [1] 1 2 3 # Aufruf der zweiten Variable mit ihrem Namen var2 list2$var2 #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; # Objektbestimmung typeof(list2) #&gt; [1] &quot;list&quot; Im Environment gibt sich folgende Datenstruktur. Wichtig! Elemente in Listen können unendlich “gestapelt” werden und folgend mit einer Verschränkung des [] Operator “entpackt” werden. list3 &lt;- list(list1 = list1, list2 = list(var1 = c(1, 2, 3, 4, 5), var2 = &quot;a&quot;), var1 = 1:100) # Liste1 aus Liste3 entpacken list3$list1 #&gt; [[1]] #&gt; [1] 1 2 3 #&gt; #&gt; [[2]] #&gt; [1] &quot;a&quot; #&gt; #&gt; [[3]] #&gt; [1] 1.22 2.00 3.44 4.00 5.00 #&gt; #&gt; [[4]] #&gt; [1] TRUE FALSE FALSE # var1 aus liste1 in liste3 entpacken list3$list1[1] #&gt; [[1]] #&gt; [1] 1 2 3 # var2 aus liste2 in liste3 entpacken list3$list2$var2 #&gt; [1] &quot;a&quot; # Erster Wert aus var1 in list1 über list3 entpacken list3$list1[[1]][1] #&gt; [1] 1 2.3.5 Weitere Datentypen R kennt noch zwei weitere Datentypen (Matrizen und Arrays), die wir in diesem Kurs ausklammern werden. Sofern interesse besteht, verweisen wir auf das Buch von Hadley Wickham: Advanced R. 2.4 Pipe Operatoren In Kapitel 2.2.1 konnten wir schon sehen, dass es schnell unübersichtlich werden kann, wenn wir Funktionen ineinander verschachteln. Vor allem bei der Datenverarbeitung entsteht sehr schnell unübersichtlicher Code. Hierfür gibt es in R eine “ganz einfache” Lösung - Pipes. So lassen sich Sequenzen von Funktionen sehr elegant abbilden. Eine Pipe zeigt sich immer durch den %&gt;% Operator an. Um auf diesen zugreifen zu können, müssen wir eig. das Packet magrittr laden. Da aber die Packete des tidyverse den Operator automatisch laden, müssen wir zumindest in seiner einfachsten Form keinen zusätzlichen Aufwand betreiben. Nun wollen wir aber mit zwei weiteren Formen des Pipe-Operators arbeiten (%$% und %T&gt;%), die uns nur über das Laden von magrittr zur Verfügung gestellt werden. install.packages(&quot;magrittr&quot;) library(magrittr) %&gt;% Operator Tipp: Um schnell auf den Pipe Operator zugreifen zu können, bietet sich das Tastenkürzel cmd bzw. strg + up + M an. Um einen ersten Einstieg zu schaffen, greifen auf unser Beispiel aus Kapitel 2.2.1 zurück. Hier haben wir den Vektor c(1.11, 1.22, 1.33, 1.44, 1.55), welcher in var1 gespeichert wurde, gerundet. # Vektor speichern in var1 var1 &lt;- c(1.11, 1.22, 1.33, 1.44, 1.55) # var1 runden round(var1, digits = 1) #&gt; [1] 1.1 1.2 1.3 1.4 1.6 In diesem Stadium ist unser Code noch sehr übersichtlich. Wir können aber auch schon jetzt eine Pipe zu Demonstrationszwecken bilden. # Vektor speichern in var1 var1 &lt;- c(1.11, 1.22, 1.33, 1.44, 1.55) # var1 runden var1 %&gt;% round(digits = 1) #&gt; [1] 1.1 1.2 1.3 1.4 1.6 Der Effekt ist für unser Beispiel klein, aber die Idee ist klar. Wir schreiben mit der Pipe also Funktionen nicht mehr als f(x) sondern als x %&gt;% f() bzw. x %&gt;% f. Wir reihen also unsere Funktionen aneinander, wir verschachteln sie nicht mehr. Im nächsten Schritt wollen wir unseren gerundeten Vektor in eine weitere Funktion übergeben, dann wird auch der Effekt dieses Vorgehens ersichtlich. Wir rufen zusätzlich mit head() die ersten drei Elemente unseres Vektors auf. # Vektor speichern in var1 var1 &lt;- c(1.11, 1.22, 1.33, 1.44, 1.55) # var1 runden und die ersten drei Elemente abrufen head(round(var1, digits = 1), n = 3) #&gt; [1] 1.1 1.2 1.3 # var1 runden und die ersten drei Elemente abrufen - Pipe var1 %&gt;% round(digits = 1) %&gt;% head(n = 3) #&gt; [1] 1.1 1.2 1.3 Wie wir sehen können, wird der Vektor var1 durch die Funktionen “weitergegeben.” Tatsächlich gibt jede Funktion ihren Output, also ihr Ergebnis, an die nächste weiter. Im ersten Beispiel passiert das von “innen nach außen.” Damit wird es schnell unübersichtlich, zumal anstrengend zu schreiben. In der Pipe hingegen, erzeugen wir eine lineare Übergabe von Funktion zu Funktion. Der Ablauf der Pipe in Kürze: Der Vektor aus var1 wird also an die Funktion round() weitergegeben und in dieser auf eine Nachkommastelle gerundet. Damit haben wir an diesem Punkt den Output: c(1.1, 1.2, 1.3, 1.4, 1.6). Im nächsten Schritt wird dieser Output an head() übergeben. In head() rufen wir nur die ersten drei Elemente ab, also c(1.1, 1.2, 1.3). Vorteile: Unser Code ist lesbarer Wir müssen keine unnötigen Variablen definieren Wir können diesen Prozess auch mit dem Platzhalter-Operator . veranschaulichen. Dieser steht immer für den Output aus der letzten Funktion. # Vektor speichern in var1 var1 &lt;- c(1.11, 1.22, 1.33, 1.44, 1.55) # var1 runden und die ersten drei Elemente abrufen - Pipe var1 %&gt;% round(x = ., digits = 1) %&gt;% head(x = ., n = 3) #&gt; [1] 1.1 1.2 1.3 Ziemlich schick, nicht wahr? Der Platzhalter lässt sich aber auch an jeder anderen Stelle in der Funktion als Wertcontainer einsetzen. # Vektor speichern in var1 var1 &lt;- c(1.11, 1.22, 1.33, 1.44, 1.55) # var1 runden und die ersten drei Elemente abrufen - Pipe 1 %&gt;% round(var1, digits = .) %&gt;% head(x = ., n = 3) #&gt; [1] 1.1 1.2 1.3 Wichtig! Wollen wir ohne einen Platzhalter arbeiten, muss das erste Argument der nachfolgenden Funktion den Output der vorherigen aufnehmen können - i.d.R. x = Daten (Datensatz oder Variablen). In den meisten Fällen ist auch das Objekt, welches übergeben wird, gleichzeitig das erste Argument der nächsten Funktion (vor allem für die tidyverse-Funktionen), so dass wir diesen Platzhalter selten brauchen werden. Wir haben alle Funktionen in diesem Kurs nach diesem Kriterium ausgewählt, um eine möglichst reibungslose Einarbeitung zu ermöglichen. Anmerkung: Der Verkettung von Funktionen ist damit praktisch kein Limit gesetzt, außer ein paar Regeln an die man sich halten sollte. Pipes sollten nicht genutzt werden, wenn die Pipe länger als 10 Schritte wäre, mehrere Inputs oder Outputs benötigt werden, eine komplexe Objektstruktur das Ziel ist. %$% Operator Für Funktionen, die auf Variablenebene arbeiten und keinen Datensatz als Dateninput erlauben, gibt es den %$% Operator. Wichtig! Wir brauchen diesen Operator aber nur für ganz wenige Funktionen. Die meisten Funktionen die auf Variablenebene arbeiten, besitzen gleichzeitig auch als erstes Argument eine Datensatz-Schnittstelle - x = Datensatz. Sie greifen dann über das zweite Argument auf die Variablen in diesem Datensatz zu. Der %$% Operator ermöglicht letztlich, dass wir gezielt einzelne Variablen aus dem Datensatz in der nächsten Funktion anwählen können, auch wenn es keine Datensatz-Schnittstelle gibt. In unserem Beispiel benötigt die Funktion ts.plot, als Grafik für Zeitachsenmessungen, eine Variable als Input - x = Variable. Es darf also kein Datensatz eingespeist werden. Folglich brauchen wir den %$% Operator, um auf Variablenebene operieren zu können. # Vektoren in Datensatz speichern var1 &lt;- c(1, 1, 2, 2, 2, 3, 3, 3, 3) var2 &lt;- c(8, 9, 1, 1, 2, 3, 4, 5, 4) ds1 &lt;- tibble(var1, var2) # Mit dem %$% Operator ds1 %$% ts.plot(var1) %T&gt;% Operator Dieser Operator ermöglicht es eine Pipe auch bei Funktionen ohne “inhaltlichen” Output weiterzuführen. Grafiken haben letztlich keinen Output außer der Grafikausgabe und würden so eine Verkettung von Funktionen beenden. Wollen wir aber zu unserer Grafik noch einen “inhaltlichen” Output, brauchen wir den %T&gt;% Operator. Dieser wird hinter den letzten Output geschrieben, auf den wir uns beziehen wollen. Unser Wert wird damit auch an die übernächste Funktion “weitergegeben.” Es wird also immer auf den linken Wert neben dem %T&gt;% Operator zugegriffen und dieser an alle folgenden Funktionen “weitergegeben.” var1 &lt;- c(1.11, 1.22, 1.33, 1.44, 1.55) var1 %&gt;% round(digits = 2) %T&gt;% plot() %&gt;% head(n = 3) #&gt; [1] 1.11 1.22 1.33 So können wir uns einen Grafikoutput, wie auch die ersten drei Elemente von unserem gerundeten Vektor ausgeben lassen. Hervorangend! Jetzt können wir mit der Bearbeitung unseres Datensatzes beginnen. "],["datenverarbeitung.html", "3 Datenverarbeitung 3.1 Vorbereitung 3.2 Datensatz importieren 3.3 Erster Blick auf den Datensatz 3.4 Datensatz restrukturieren 3.5 Daten konvertieren 3.6 Daten beschriften 3.7 Daten manipulieren", " 3 Datenverarbeitung In diesem Kapitel werden wir in einem ersten Schritt das Einlesen von Datensätzen in den geläufigen Datenstrurkturen kennenlernen, um in einem zweiten Schritt die Daten nach unseren Vorstellungen zu modifizieren. Tipp: Zur Erstellung eigener Datensätze empfehlen wir das Kapitel Datensätze selber erstellen von Andrew Ellis und Boris Mayer. Wie Eingangs erwähnt, arbeiten wir in diesem Kurs mit den Ökosystemen tidyverse und strengejacke, um Daten umfänglich modifizieren zu können. Natürlich gibt es auch andere Möglichkeiten der Datenbearbeitung. Wir sind aber davon überzeugt, dass die “tidyverse-Methode,” an die sich auch strengejacke anschließt, eine sehr konsistente und eingängige Form des Arbeitens ermöglicht. Wie wir später noch sehen werden, erfordern viele Arten von statistischen Analysen und insbesondere Grafik-Funktionen einen Datensatz im long-Format. So muss mitunter erstaunlich viel Zeit für die Organisation von Daten für die weitere Analyse aufgewendet werden (diese Art von Arbeit wird oft als “data wrangling” bezeichnet). Sofern Sie einen Datensatz im wide-Format in ein long-Format transformieren wollen, empfehlen wir das Kapitel: Reshaping: tidyr von Andrew Ellis und Boris Mayer. 3.1 Vorbereitung Wir wollen mit dem Allbus-Datensatz (Allgemeine Bevölkerungsumfrage der Sozialwissenschaften) von 2018 arbeiten. Dieser lässt sich über GESIS unter: Allbus 2018 herunterladen. Der Allbus 2018 liegt gleich im long-Format vor. Anmerkung: Der Allbus 2018 ist eine standardisierte Bevölkerungsbefragung mit überproportionaler Repräsentanz von Befragten aus den neuen Bundesländern. Um diesem Umstand gerecht zu werden, müssen die Daten des Allbus gewichtet werden. Eine ideale Voraussetzung für diesen Kurs. Wir wollen unserem Anspruch einer zielgerichteten und forschungspraktischen Anwendung von R auch während der Bearbeitung des Allbus 2018, als Datengrundlage, gerecht werden. So greifen wir auf vergangene Forschungspublikationen zurück. Diese erlauben uns eine Orientierungslinie für kommende Beispiele zu ziehen. Folgend erstellen wir ein Projekt in RStudio (siehe 1.8.1). Sobald der Projektordner erstellt wurde, schieben wir unseren Datensatz in den Projektordner. Durch die Festlegung unseres Arbeitsverzeichnises im Projektordner, kann R direkt auf den Datensatz zugreifen. Der Reiter Files sollte entsprechend so aussehen: Abschließend erstellen wir ein RScript (siehe 1.8.2) und laden unsere Packete: tidyverse, strengejacke und easystats (siehe 1.6). Voila! Nun können wir den Datensatz einlesen. 3.2 Datensatz importieren Durch das Packet sjlabelled aus dem Packet strengejacke können wir drei verschiedene Dateiformate einlesen. .sav &gt; SPSS .dta &gt; Stata .sas &gt; SAS Da wir den Allbus 2018 in .sav vorliegen haben, benutzen wir die folgende Funktion. # SPSS allbus2018 &lt;- read_spss(&quot;ALLB2018.sav&quot;) Wichtig! Mit der Funktion read_spss() über das Packet sjlabelled werden alle fehlenden Werte zu NA konvertiert. Sofern Sie mit fehlenden Werten arbeiten wollen, empfehlen wir gegenwärtig noch das Packet haven über die Funktion read_sav() und dem Argument user_na = TRUE zu nutzen. Hier ist aber zu beachten, dass alle Vektoren unter der Klasse labelled_spss gespeichert werden. Das kann zu Problemen mit Funktionen aus externen Packeten führen. Eine Lösung wäre vorher die betreffenden Vektoren händisch in atomare Strukturen zu konvertieren (z.B. durch unlabel() aus sjlabelled). Zudem müssen dann alle fehlenden Werte händisch als NA makiert werden (set_na() aus sjlabelled). Dazu aber später mehr! Sollten Ihre Daten in .dta oder .sas vorliegen, können Sie die folgenden Befehle nutzen. # Stata allbus2018 &lt;- read_stata(&quot;Datensatz.dta&quot;) # SAS allbus2018 &lt;- read_sas(&quot;Datensatz.sas&quot;) Anmerkung: Sollten Sie andere Dateiformate nutzen wollen, bieten sich zudem die Packete haven, readxl und readr an. Die Funktion read_spss besitzt vier für uns relevante Argumente. Einen Überblick über die möglichen Argumente findet sich unter: ?read_spss. atomic.to.fac = TRUE &gt; Alle Variablen mit beschrifteten Ausprägungsmerkmalen werden zu Faktoren konvertiert. Für uns ist dieses Argument offensichtlich unbrauchbar, da wir viele Items vom Likert-Typ im Allbus 2018 vorfinden und diese als pseudo-metrisch behandeln wollen. drop.labels = TRUE &gt; Alle Ausprägungsmerkmale ohne Fälle werden gelöscht. Eine nützliche Funktion, sofern wir nicht mit fehlenden Werten arbeiten möchten. Durch read_spss() über das Packet sjlabelled wurden ohnehin alle vormalig fehlenden Werte zu NA konvertiert. So können wir die überflüssigen Ausprägungsmerkmale einfach löschen. verbose = TRUE &gt; Es wird beim Verarbeiten der Daten ein Fortschrittsbalken eingeblendet. Nur bei großen Datensätzen relevant. tag.na = TRUE &gt; Alle fehlenden Werte werden als tagged_na markiert. Damit werden sie in allen Berechnungen zwar als NA einbezogen, der große Vorteil dieses Vorgehens liegt aber im Erhalt der ursprünglichen Kodierung jener fehlenden Werte. Wir können also wie aus SPSS bekannt, jederzeit auf diese mit der Funktion replace_na() zugreifen und sie als reguläre Werte in unsere Berechungen aufnehmen. Leider funktioniert dieses Argument gegenwärtig nur mit positiven Kodierungsmerkmalen (z.B. 98, 99), aber nicht mit negativen Ausprägungsformen (-7, -8). Wir hoffen auf eine baldige Anpassung und stehen mit den Entwicklern im Kontakt. Damit empfehlen wir das Argument dop.labels mit TRUE bzw. T zu aktivieren. allbus2018 &lt;- read_spss(&quot;ALLB2018.sav&quot;, drop.labels = T) # Noch schnell den Allbus zum tibble transformieren allbus2018 &lt;- tibble(allbus2018) Hervorragend! Damit haben wir erfolgreich unsere Daten in R importiert. Um bearbeitete Datensätze zu speichern, bietet sich der folgende Befehl an. write_spss(allbus2018, path = &quot;allbus2018&quot;) Die Datei wird automatisch in unserem Projektordner abgelegt. Wir können aber auch über das Argument path einen neuen Speicherort definieren. 3.3 Erster Blick auf den Datensatz Nachdem wir unseren Datensatz eingelesen haben, wollen wir uns zu Beginn einen Überblick über die vorhandenen Daten verschaffen. Mit view() können wir den ganzen Datensatz als zusätzliches Fenster öffnen. view(allbus2018) Über den Befehl view_df() wird uns eine HTML-Version unseres Datensatzes im Viewer angezeigt. view_df(allbus2018) Der große Vorteil der zweiten Abbildung liegt offensichtlich in der reduzierten Darstellung. So können wir über die Spalte ID ablesen, welchen Wert unsere Variablen im Spaltenvektor des Datensatzes innehaben. Wir können entsprechend Variablen über diesen indizieren. Zudem wird uns die Variablenbezeichnung über Name, die Variablenbeschriftung über Label und die Ausprägungsmerkmale bzw. Spannweite über Values, sowie die Merkmalsbeschriftung über Value Labels ausgegeben. Weiterhin können wir über unsere zuvor erlernten “Grundfunktionen” einen Ausschnitt des Datensatzes generieren. # Ersten 3 Fälle head(allbus2018, n = 3) # Letzten 5 Fälle tail(allbus2018, n = 5) #Ganzer Datensatz print(allbus2018) Die Anwendung unserer Grundfunktionen hat gegenwärtig noch den großen Nachteil, dass R versucht alle Variablen unseres Datensatzes abzubilden. Um das in den Griff zu bekommen, wollen wir uns in den folgenden Kapiteln mit der Datensatztransformation und dann Datenmanipulation beschäftigen. 3.4 Datensatz restrukturieren Anmerkung: Ab jetzt werden wir mit dem Allbus 2018 arbeiten. Um die folgenden Befehle nachvollziehen zu können, sollte Sie den Datensatz entsprechend eingelesen haben. Gemäß unseres forschungspraktischen Anspruchs stammen die kommenden Variablen aus einer Untersuchung politischen Wissens (Moosdorf 2020) in Bearbeitung des Allbus 2018. Kurze Erläuterung des Forschungsinhalts R verspricht eine enorme Flexibilität im Umgang mit Daten. Unmittelbar spürbar wird dieser Umstand in der Reorganisation von Datensätzen in neuen Objekten (gezielt aufgebaute eigene Datensätze). So wollen wir in einem ersten Schritt lernen, wie wir Datensätze grob restrukturieren und anschließend die Daten in einem neuen Datensatz speichern können. Unser Ziel ist es also einen eigenen, auf unsere Bedürfnisse zugeschnittenen, Datensatz zu erzeugen. Hierfür straten wir mit den folgenden Funktionen: Packet Funktion Verwendung dplyr select() Selektieren von Variablen dplyr filter() Filtern nach Fällen mit spezifischer Ausprägung dplyr arrange() Sortiert Datensatz nach bestimmter Variable Das dplyr Package stellt Funktionen für alle diese Aufgaben zur Verfügung (und noch viele mehr, wir betrachten hier nur eine kleine Auswahl). dplyr besteht sozusagen aus Verben (Funktionen) für all diese Operationen, und diese Funktionen können - je nach Bedarf - auf sehr elegante Weise zusammengesetzt werden. Wir sehen uns nun der Reihe nach die verschiedenen Funktionen und deren Verwendung an. Wir verwenden immer den %&gt;% Operator. Der Input Datensatz ist dabei immer als erstes Argument der Funktion zu verstehen. Select() Mit der Funktion select() lassen sich Variablen aus einem Datensatz gezielt auswählen. Syntax: # Ohne Pipe select(datensatz, variable1, variable2:variable3, -variable4) # Mit Pipe datensatz %&gt;% select(variable1, variable2:variable3, -variable4) Mit dem Befehl select() wurden aus dem Datensatz datensatz die Variablen variable1, variable2 bis variable3 ausgewählt. variable4 wurde weggelassen. Beispielcode: # Nur Einstellung zu Leistungsprinzip (im19) im neuen Datensatz ds speichern ds &lt;- allbus2018 %&gt;% select(im19) ds #&gt; # A tibble: 3,477 x 1 #&gt; im19 #&gt; &lt;dbl&gt; #&gt; 1 4 #&gt; 2 4 #&gt; 3 2 #&gt; 4 4 #&gt; 5 4 #&gt; 6 2 #&gt; 7 4 #&gt; 8 4 #&gt; 9 3 #&gt; 10 4 #&gt; # … with 3,467 more rows # Einstellungen zum Leistungsprinzip (im19) und Befürwortung von Ungleichheit (im20) # in ds speichern ds &lt;- allbus2018 %&gt;% select(im19, im20) ds #&gt; # A tibble: 3,477 x 2 #&gt; im19 im20 #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 2 #&gt; 2 4 4 #&gt; 3 2 3 #&gt; 4 4 2 #&gt; 5 4 4 #&gt; 6 2 2 #&gt; 7 4 4 #&gt; 8 4 3 #&gt; 9 3 2 #&gt; 10 4 3 #&gt; # … with 3,467 more rows # Befürwortung von Ungleichheit (im20) aus ds löschen ds &lt;- ds %&gt;% select(-im20) ds #&gt; # A tibble: 3,477 x 1 #&gt; im19 #&gt; &lt;dbl&gt; #&gt; 1 4 #&gt; 2 4 #&gt; 3 2 #&gt; 4 4 #&gt; 5 4 #&gt; 6 2 #&gt; 7 4 #&gt; 8 4 #&gt; 9 3 #&gt; 10 4 #&gt; # … with 3,467 more rows # Auswahl von Einstellung zum Leistungsprinzip (im19) # über Befürwortung von Ungleichheit (im20) # bis Einstellung zu sozialer Ungleichheit auf Makroebene (im21) und Mikroebene (id01) # in ds speichern ds &lt;- allbus2018 %&gt;% select(im19:im21, id01) ds #&gt; # A tibble: 3,477 x 4 #&gt; im19 im20 im21 id01 #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 2 3 3 #&gt; 2 4 4 4 2 #&gt; 3 2 3 3 3 #&gt; 4 4 2 2 3 #&gt; 5 4 4 4 2 #&gt; 6 2 2 3 3 #&gt; 7 4 4 3 3 #&gt; 8 4 3 3 2 #&gt; 9 3 2 2 3 #&gt; 10 4 3 4 3 #&gt; # … with 3,467 more rows Wir können über select() auch die Reihenfolge unseres Spaltenvektors gezielt bestimmen. # Reheinfolge des Datensatz ds anpassen ds &lt;- allbus2018 %&gt;% select(id01, im19, im20, im21) ds #&gt; # A tibble: 3,477 x 4 #&gt; id01 im19 im20 im21 #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 3 4 2 3 #&gt; 2 2 4 4 4 #&gt; 3 3 2 3 3 #&gt; 4 3 4 2 2 #&gt; 5 2 4 4 4 #&gt; 6 3 2 2 3 #&gt; 7 3 4 4 3 #&gt; 8 2 4 3 3 #&gt; 9 3 3 2 2 #&gt; 10 3 4 3 4 #&gt; # … with 3,467 more rows Anmerkung: Viele Funktionen des tidyverse, auch select(), besitzen zusätzlich Hilfsfunktionen und erweiterte Funktionsvarianten, um gezielt mehrere Variablen nach bestimmten Kriterien einschließen zu können. In Anbetracht der umfänglichen Möglichkeiten dieses Vorgehens, können wir leider in diesem Kurs nicht darauf eingehen. Sofern Sie bedarf für Ihre eigenen Arbeiten sehen, empfehlen wir in der Packetdokumentation nachzusehen unter: selection helpers und scoped verbs. Sofern Sie einzelne Variablen im Datensatz verschieben möchten, empfehlen wir die Funktion move_columns() aus dem Packet sjmisc. Filter() Mit der Funktion filter() können wir eine Auswahl von Fällen treffen, die alle eine bestimmte Ausprägung einer Variable besitzen. Tipp: Wir kennen diesen Befehl aus SPSS als select if. Um unsere Daten ausgiebig filtern zu können, müssen wir uns kurz mit den logischen Operatoren in R beschäftigen. &lt; Kleiner &lt;= Kleiner gleich &gt; Grösser &gt;= Grösser gleich == Gleich (testet auf Äquivalenz) != Ungleich x | y x ODER y x &amp; y x UND y xor(x, y) Exklusives ODER (entweder in x oder y, aber nicht in beiden) Die logischen Operatoren in R sind recht selbsterklärend und sollten bei eigener Anwendung recht schnell verstanden sein. Zusätzlich brauchen wir noch einen infix operator. %in% Merkmale in einem Vektor Syntax: # Ohne Pipe filter(datensatz, variable1 == 1) # Mit Pipe datensatz %&gt;% filter(variable1 == 1) Mit dem Befehl filter() wurden nur die Fälle des Datensatzes datensatz mit der Ausprägung 1 der Variable variable1 übernommen. Beispielcode: # Auswahl unserer bekannten Variablen gefiltert nach Personen mit NUR der # deutschen Staatsbürgerschaft ds &lt;- allbus2018 %&gt;% select(im19:im21, id01, german) %&gt;% filter(german == 1) ds #&gt; # A tibble: 3,218 x 5 #&gt; im19 im20 im21 id01 german #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 2 3 3 1 #&gt; 2 4 4 4 2 1 #&gt; 3 2 3 3 3 1 #&gt; 4 4 2 2 3 1 #&gt; 5 4 4 4 2 1 #&gt; 6 2 2 3 3 1 #&gt; 7 4 4 3 3 1 #&gt; 8 4 3 3 2 1 #&gt; 9 3 2 2 3 1 #&gt; 10 4 3 4 3 1 #&gt; # … with 3,208 more rows # Auswahl unserer bekannten Variablen gefiltert nach Personen mit der # deutschen Staatsbürgerschaft (auch mit weiteren) ds &lt;- allbus2018 %&gt;% select(im19:im21, id01, german) %&gt;% filter(german %in% 1:2) ds #&gt; # A tibble: 3,268 x 5 #&gt; im19 im20 im21 id01 german #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 2 3 3 1 #&gt; 2 4 4 4 2 1 #&gt; 3 2 3 3 3 1 #&gt; 4 4 2 2 3 1 #&gt; 5 4 4 4 2 1 #&gt; 6 2 2 3 3 1 #&gt; 7 4 4 3 3 1 #&gt; 8 4 3 3 2 1 #&gt; 9 3 2 2 3 1 #&gt; 10 4 3 4 3 1 #&gt; # … with 3,258 more rows # Auswahl unserer bekannten Variablen gefiltert nach Personen mit der # deutschen Staatsbürgerschaft (auch mit weiteren) und weiblichem Geschlecht ds &lt;- allbus2018 %&gt;% select(im19:im21, id01, german, sex) %&gt;% filter(german %in% c(1,2) &amp; sex == 2) ds #&gt; # A tibble: 1,610 x 6 #&gt; im19 im20 im21 id01 german sex #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 4 4 2 1 2 #&gt; 2 4 4 4 2 1 2 #&gt; 3 4 4 3 3 1 2 #&gt; 4 3 2 2 3 1 2 #&gt; 5 4 3 4 3 1 2 #&gt; 6 2 NA 4 2 1 2 #&gt; 7 4 2 3 2 1 2 #&gt; 8 2 3 4 2 1 2 #&gt; 9 2 2 4 NA 1 2 #&gt; 10 2 3 3 2 1 2 #&gt; # … with 1,600 more rows Arrange() Mit arrange() können wir Beobachtungen sortieren, entweder in aufsteigender oder in absteigender Reihenfolge. Syntax: # aufsteigend arrange(datensatz, variable1) datensatz %&gt;% arrange(variable1) # absteigend arrange(datensatz, desc(variable1)) datensatz %&gt;% arrange(desc(variable1)) Beispielcode: # Sortieren nach Alter aufsteigend ds &lt;- allbus2018 %&gt;% select(age, im19:im21, id01, german, sex) %&gt;% arrange(age) ds #&gt; # A tibble: 3,477 x 7 #&gt; age im19 im20 im21 id01 german sex #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 18 3 1 2 2 1 1 #&gt; 2 18 3 3 3 3 1 2 #&gt; 3 18 3 3 4 3 1 2 #&gt; 4 18 3 2 3 3 1 1 #&gt; 5 18 4 2 4 2 1 1 #&gt; 6 18 2 3 3 3 1 2 #&gt; 7 18 2 1 2 2 1 1 #&gt; 8 18 2 2 3 3 1 1 #&gt; 9 18 2 2 3 3 1 1 #&gt; 10 18 2 2 2 3 2 1 #&gt; # … with 3,467 more rows # Sortieren nach Alter absteigend ds &lt;- allbus2018 %&gt;% select(age, im19:im21, id01, german, sex) %&gt;% arrange(desc(age)) ds #&gt; # A tibble: 3,477 x 7 #&gt; age im19 im20 im21 id01 german sex #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 95 2 2 2 3 1 1 #&gt; 2 94 2 2 3 4 1 1 #&gt; 3 94 2 2 3 1 1 1 #&gt; 4 92 3 3 4 2 1 2 #&gt; 5 92 2 1 2 3 1 2 #&gt; 6 92 2 2 2 3 1 2 #&gt; 7 92 1 4 4 2 1 1 #&gt; 8 92 NA 2 2 2 1 2 #&gt; 9 92 2 2 3 3 1 1 #&gt; 10 92 2 2 4 3 1 1 #&gt; # … with 3,467 more rows 3.5 Daten konvertieren So wollen wir uns den Funktionen zuwenden, die Datentypen verändern. Anmerkung: Wir benutzen die Packete sjmisc und sjlabelled zur Konvertierung von Datentypen, weil die Anwendung der base R Funktionen alle Beschriftungen (siehe 3.3) unseres Datensatzes entfernen würde. Zudem sind die base R Funktionen nicht für die Nutzung in einer Pipe optimiert. Packet Funktion Verwendung sjlabelled to_factor() Konvertiert Variable in Faktor mit numerischen levels sjlabelled to_label() Konvertiert Variable in Faktor mit beschrifteten levels sjlabelled to_numeric() Konvertiert Variable in numerischen Vektor sjlabelled to_character() Konvertiert Variable in character Vektor sjmisc numeric_to_factor() Konvertiert Variablen mit n Ausprägungsmerkmalen zu Faktor sjlabelled unlabel() Konvertiert labelled class in atomare Struktur sjmisc ref_lvl() Setzt Referenzkategorie To_factor() Konvertiert einen Vektor in einen Faktor mit numerischen levels - äquivalent zur Funktion factor(). Sinnvoll bei Variablen mit mehr als zwei Ausprägungsmerkmalen. Syntax: # Ohne Pipe to_factor(datensatz$variable1, datensatz$variable2) # Mit Pipe datensatz %&gt;% to_factor(variable1, variable2) Beispielcode: # Geschlecht unbearbeitet class(allbus2018$sex) #&gt; [1] &quot;numeric&quot; # Geschlecht in Faktor mit numerischen levels konvertieren ds &lt;- allbus2018 %&gt;% select(sex) %&gt;% to_factor(sex) attributes(ds$sex) #&gt; $levels #&gt; [1] &quot;1&quot; &quot;2&quot; #&gt; #&gt; $class #&gt; [1] &quot;factor&quot; #&gt; #&gt; $labels #&gt; MANN FRAU #&gt; 1 2 #&gt; #&gt; $label #&gt; [1] &quot;GESCHLECHT, BEFRAGTE(R)&quot; To_label() Konvertiert einen Vektor in einen Faktor mit beschrifteten levels. Sinvoll bei binären Ausprägungsmerkmalen. Syntax: # Ohne Pipe to_label(datensatz$variable1, datensatz$variable2) # Mit Pipe datensatz %&gt;% to_label(variable1, variable2) Beispielcode: # Geschlecht in Faktor mit beschrifteten levels konvertieren ds &lt;- allbus2018 %&gt;% select(sex) %&gt;% to_label(sex) attributes(ds$sex) #&gt; $levels #&gt; [1] &quot;MANN&quot; &quot;FRAU&quot; #&gt; #&gt; $class #&gt; [1] &quot;factor&quot; #&gt; #&gt; $label #&gt; [1] &quot;GESCHLECHT, BEFRAGTE(R)&quot; To_numeric() Konvertiert einen Faktor oder character Vektor in einen numerischen Vektor. Syntax: # Ohne Pipe to_numeric(datensatz$variable1, datensatz$variable2) # Mit Pipe datensatz %&gt;% to_numeric(variable1, variable2) Beispielcode: # Geschlecht in Faktor ds &lt;- allbus2018 %&gt;% select(sex) %&gt;% to_factor(sex) # Geschlecht wieder in numerischen Vektor konvertieren ds &lt;- ds %&gt;% select(sex) %&gt;% to_numeric(sex) class(ds$sex) #&gt; [1] &quot;numeric&quot; To_character() Konvertiert einen numerischen Vektor oder Faktor in einen character Vektor. Syntax: # Ohne Pipe to_character(datensatz$variable1, datensatz$variable2) # Mit Pipe datensatz %&gt;% to_character(variable1, variable2) Beispielcode: # Geschlecht in character Vektor konvertieren ds &lt;- allbus2018 %&gt;% select(sex) %&gt;% to_character(sex) class(ds$sex) #&gt; [1] &quot;character&quot; # Folge: Alle numerischen Ausprägungsmerkmale wurden in ihre Beschriftung umgewandelt str(ds$sex) #&gt; chr [1:3477] &quot;MANN&quot; &quot;FRAU&quot; &quot;MANN&quot; &quot;MANN&quot; &quot;FRAU&quot; &quot;MANN&quot; &quot;FRAU&quot; &quot;MANN&quot; ... #&gt; - attr(*, &quot;label&quot;)= chr &quot;GESCHLECHT, BEFRAGTE(R)&quot; Numeric_to_factor() Diese Funktion ermöglicht es uns alle Variablen eines Datensatzes anzuwählen und diese zu einem Faktor zu konvertieren. Wir müssen lediglich eine Maximalgrenze (n) als gewünschten Grenzwert zur Umwandlung angeben. Hat eine Variable weniger oder gleich viele Ausprägungsmerkmale wird sie konvertiert. Beispielcode: # Datensatz als Ausgangspunkt ds &lt;- allbus2018 %&gt;% select(im19:im21, id01) class(ds$im19) #&gt; [1] &quot;numeric&quot; # Alle Variablen haben nur bis zu vier Ausprägungsmerkmale # Wir können sie entsprechend zu Faktoren konvertieren # ACHTUNG: Diese Funktion ändert den Datentyp unseres Datensatzes! # Wir geben also zusätzliche die Funktion tibble() an ds &lt;- ds %&gt;% numeric_to_factor(n = 4) %&gt;% tibble() class(ds$im19) #&gt; [1] &quot;factor&quot; Wichtig! Die Funktion numeric_to_factor() hat die gleiche Wirkung wie die Funktion to_label(). Wir sparen uns lediglich den Aufwand jede Variable einzeln anzuwählen. Unlabel() Mit dieser Funktion können wir Variablen konvertieren, die als labelled class gespeichert wurden. Durch das Einlesen unseres Datensatzes über read_spss() werden wir diesen Befehl praktisch nie brauchen. Sollte wir den Datensatz aber über haven mit der Funktion read_sav() laden, ist es sinnvoll alle Variablen nach der Bearbeitung in eine atomare Struktur umzuwandeln - damit lassen sich spätere Probleme mit zusätzlichen Packeten vorbeugen. Beispielcode: # Datensatz laden und vorbereiten library(haven) #&gt; #&gt; Attaching package: &#39;haven&#39; #&gt; The following objects are masked from &#39;package:sjlabelled&#39;: #&gt; #&gt; as_factor, read_sas, read_spss, read_stata, write_sas, zap_labels allbus2018_haven &lt;- read_sav(&quot;ALLB2018.sav&quot;) ds &lt;- allbus2018_haven %&gt;% select(age, im19:im21, id01, german, sex) # Beispiel class(ds$age) #&gt; [1] &quot;haven_labelled&quot; &quot;vctrs_vctr&quot; &quot;double&quot; # Wir konvertieren alle Variablen # ACHTUNG: Diese Funktion ändert den Datentyp unseres Datensatzes! # Wir geben also zusätzliche die Funktion tibble() an ds &lt;- ds %&gt;% unlabel() %&gt;% tibble() class(ds$age) #&gt; [1] &quot;numeric&quot; Ref_lvl() Die Verwendung der Funktion rev_lvl() aus sjmisc hat den großen Vorteil, dass unser Faktor im Gegensatz zur Funktion relevel() rekodiert wird und damit alle Beschriftungen auch bei numerischen levels richtig zugewiesen werden können. Syntax: # Ohne Pipe rev_lvl(datensatz, variable1, lvl = 3) # Mit Pipe datensatz %&gt;% ref_lvl(variable1, lvl = 3) Wir ändern mit der Funktion ref_lvl() die Referenzkategorie von variable1 auf das Ausprägungsmerkmal 3. Beispielcode: # Geschlecht als Faktor ds &lt;- allbus2018 %&gt;% select(sex) %&gt;% to_factor(sex) # Unsere Refrenzkategorie ist gegenwärtig &quot;Mann&quot; attributes(ds$sex) #&gt; $levels #&gt; [1] &quot;1&quot; &quot;2&quot; #&gt; #&gt; $class #&gt; [1] &quot;factor&quot; #&gt; #&gt; $labels #&gt; MANN FRAU #&gt; 1 2 #&gt; #&gt; $label #&gt; [1] &quot;GESCHLECHT, BEFRAGTE(R)&quot; # Wir ändern die Refrenkategorie folgend auf &quot;Frau&quot; ds &lt;- ds %&gt;% ref_lvl(sex, lvl = 2) attributes(ds$sex) #&gt; $levels #&gt; [1] &quot;1&quot; &quot;2&quot; #&gt; #&gt; $class #&gt; [1] &quot;factor&quot; #&gt; #&gt; $label #&gt; [1] &quot;GESCHLECHT, BEFRAGTE(R)&quot; #&gt; #&gt; $labels #&gt; FRAU MANN #&gt; 1 2 3.6 Daten beschriften Grundständig kennt R keine beschrifteten Daten. Erst durch den zunehmenden Einfluss sozialwisschenschaftlicher Anwendungsbedürfnisse und der bevorzugten Datenformate (.sav, .dta, .sas) halten Datenbeschriftungen auch in die R-Umgebung Einzug. Packet Funktion Verwendung sjlabelled get_label() Ruft Variablenbeschriftung ab sjlabelled get_labels() Ruft Beschriftung von Ausprägungsmerkmalen ab sjlabelled remove_label() Entfernt Variablenbeschriftung sjlabelled remove_labels() Entfernt Beschriftung von Ausprägungsmerkmalen sjlabelled remove_all_labels() Entfernt alle Beschriftungen sjlabelled var_labels() Variable neubeschriften sjlabelled val_labels() Ausprägungsmerkmale neubeschriften sjlabelled drop_labels() Alle “unbesetzten” Ausprägungsmerkmale löschen *Die Funktion drop_labels() ist äquivalent zum Argument drop.labels = T in der Funktion read_spss(). Sofern Sie ihre Daten mit read_sav() eingelesen haben, können Sie diesen Befehl nach der Bearbeitung ihres Datensatzes zur Löschung überflüssiger Merkmalsausprägungen nutzen. Get_label() Mit der Funktion get_label() können wir Variablenbeschriftungen abrufen. Syntax: # Ohne Pipe get_label(datensatz, variable1) # Mit Pipe datensatz %&gt;% get_label(variable1) Beispielcode: # Variablenbeschriftung Leistungsprinzip (im19) # und Befürwortung von Ungleichheit (im20) allbus2018 %&gt;% get_label(im19, im20) #&gt; im19 #&gt; &quot;EINKOMMENSDIFFERENZ ERHOEHT MOTIVATION&quot; #&gt; im20 #&gt; &quot;RANGUNTERSCHIEDE SIND AKZEPTABEL&quot; Get_labels() Die Funktion get_labels() erlaubt uns das Abrufen der Beschriftung von Merkmalsausprägungen. Syntax: # Ohne Pipe get_labels(datensatz, variable1) # Nicht mit Pipe möglich! Beispielcode: # Beschriftung der Ausprägungsmerkmale - Leistungsprinzip (im19) get_labels(allbus2018$im19) #&gt; [1] &quot;STIMME VOLL ZU&quot; &quot;STIMME EHER ZU&quot; &quot;STIMME EHER NICHT ZU&quot; #&gt; [4] &quot;STIMME GAR NICHT ZU&quot; Remove_label() Über die Funktion remove_label() lassen sich gezielt Variablenbeschriftungen von einzelnen Variablen oder allen Variablen im Datensatz entfernen. Syntax: # Einzelne Variable # Ohne Pipe remove_label(datensatz, variable1) # Mit Pipe datensatz %&gt;% remove_label(variable1) # --------- # Ganzer Datensatz # Ohne Pipe remove_label(datensatz) # Mit Pipe datensatz %&gt;% remove_label() Beispielcode: # Löschung der Variablenbeschriftung - Geschlecht ds &lt;- allbus2018 %&gt;% select(sex) %&gt;% remove_label(sex) # Variablenbeschriftung wurde gelöscht ds %&gt;% get_label(sex) #&gt; sex #&gt; &quot;&quot; # Löschung aller Variablenbeschriftungen im Datensatz ds &lt;- allbus2018 %&gt;% select(im19, im20) %&gt;% remove_label() # Variablenbeschriftungen wurden gelöscht ds %&gt;% get_label(im19, im20) #&gt; im19 im20 #&gt; &quot;&quot; &quot;&quot; Remove_labels() Die Funktion remove_labels() erlaubt es uns gezielt Beschriftungen der Ausprägungsmerkmale von einzelnen Variablen oder allen Variablen im Datensatz zu löschen. Syntax: # Ohne Pipe remove_labels(datensatz, variable1) # Mit Pipe datensatz %&gt;% remove_labels(variable1) # --------- # Ganzer Datensatz # Ohne Pipe remove_labels(datensatz) # Mit Pipe datensatz %&gt;% remove_labels() Beispielcode: # Löschung der Variablenbeschriftung - Geschlecht ds &lt;- allbus2018 %&gt;% select(im19) %&gt;% remove_labels(im19, labels = c(1, 2, 3, 4)) # Variablenbeschriftung wurde gelöscht get_labels(ds$im19) #&gt; NULL # Löschung aller Variablenbeschriftungen im Datensatz ds &lt;- allbus2018 %&gt;% select(im19, im20) %&gt;% remove_labels(labels = 0:99) # Variablenbeschriftungen wurden gelöscht get_labels(ds$im19) #&gt; NULL get_labels(ds$im20) #&gt; NULL Remove_all_labels() Wir können mit der Funktion remove_all_labels() alle (Variablenbeschriftungen und Beschriftungen von Merkmalsausprägungen) löschen. Syntax: # Ohne Pipe remove_all_labels(datensatz, variable1) # Mit Pipe datensatz %&gt;% remove_all_labels(variable1) Beispielcode: # Löschung aller Beschriftungen in einem Datensatz ds &lt;- allbus2018 %&gt;% select(im19, im20) %&gt;% remove_all_labels() # Variablenbeschriftungen wurden gelöscht ds %&gt;% get_label(im19, im20) #&gt; im19 im20 #&gt; &quot;&quot; &quot;&quot; # Beschriftung von Ausprägungsmerkmalen wurden gelöscht get_labels(ds$im19) #&gt; NULL get_labels(ds$im20) #&gt; NULL Var_labels() Mit der Funktion var_labels() können wir von einer oder mehreren Variablen die Variablenbeschriftung neu definieren. Syntax: # Ohne Pipe var_labels(datensatz, variable1 = &quot;Variablenbeschriftung&quot;) # Mit Pipe datensatz %&gt;% var_labels(variable1 = &quot;Variablenbeschriftung&quot;) Beispielcode: # Variablenbeschriftung neu definieren ds &lt;- ds %&gt;% var_labels(im19 = &quot;Leistungsprinzip&quot;, im20 = &quot;Befürwortung von Ungleichheit&quot;) # Variablenbeschriftungen abrufen ds %&gt;% get_label(im19, im20) #&gt; im19 im20 #&gt; &quot;Leistungsprinzip&quot; &quot;Befürwortung von Ungleichheit&quot; Val_labels() Die Funktion val_labels() erlaubt es uns Ausprägungsmerkmale für eine oder mehrere Variablen neu zu definieren. Syntax: # Ohne Pipe var_labels(datensatz, variable1 = c(&quot;1&quot;, &quot;2&quot;)) # Mit Pipe datensatz %&gt;% var_labels(variable1 = c(&quot;1&quot;, &quot;2&quot;), variable2 = c(&quot;Hallo&quot;, &quot;Tschüss&quot;)) Beispielcode: # Merkmalsausprägungen neu definieren ds &lt;- ds %&gt;% val_labels(im19 = c(&quot;Erste Stufe&quot;, &quot;Zweite Stufe&quot;, &quot;Dritte Stufe&quot;, &quot;Vierte Stufe&quot;), im20 = c(&quot;Erste Stufe&quot;, &quot;Zweite Stufe&quot;, &quot;Dritte Stufe&quot;, &quot;Vierte Stufe&quot;)) get_labels(ds$im19) #&gt; [1] &quot;Erste Stufe&quot; &quot;Zweite Stufe&quot; &quot;Dritte Stufe&quot; &quot;Vierte Stufe&quot; get_labels(ds$im20) #&gt; [1] &quot;Erste Stufe&quot; &quot;Zweite Stufe&quot; &quot;Dritte Stufe&quot; &quot;Vierte Stufe&quot; ds %&gt;% select(im19, im20) %&gt;% view_df() Data frame: . ID Name Label Values Value Labels 1 im19 Leistungsprinzip 1234 Erste StufeZweite StufeDritte StufeVierte Stufe 2 im20 Befürwortung von Ungleichheit 1234 Erste StufeZweite StufeDritte StufeVierte Stufe 3.7 Daten manipulieren Zur Manipulation/Bearbeitung unseres Datensatzes werden wir maßgeblich mit dem dplyr-Packet aus dem tidyverse und dem Packet sjmisc aus strengejacke arbeiten. Die folgende Auswahl kann nur einen Überblick über die “wichtigsten” Funktionen dieser Packete geben. Sofern Sie weitere Tranformationswünsche haben, sollten Sie unbedingt die Entwicklerseiten dieser Packete aufsuchen und nach geeigneten Funktionen suchen (siehe 1.6). Packet Funktion Verwendung dplyr rename() Umbenennen von Variablen dplyr mutate() Erstellen und verändern von vorhandenen Variablen dplyr group_by() Erstellt Gruppen (Teilmengen) dplyr summarise() Daten zusammenfassen dplyr distinct() Auswahl einzigartiger Werte dplyr case_when() Vektorisierter if-Befehl sjmisc rec() Rekodierung von Variablen sjmisc std() Z-Standardisierung von Variablen sjmisc center() Zentrierung von Variablen am Mittelwert sjmisc split_var() Aufspaltung von Variablen in n Gruppen sjmisc group_var() Aufspaltung von Variablen in Gruppen gleicher Spannweite sjmisc row_count() Zählung von Zeilenwerten sjmisc col_count() Zählung von Spaltenwerten sjmisc row_sums() Summe der Zeilenwerte sjmisc row_means() Mittelwert der Zeilenwerte sjlabelled set_na() Transformiert Ausprägungsmerkmale zu fehlenden Werten tidyr drop_na() Alle fehlenden Werte werden gelöscht Rename() Die Funktion rename() erlaubt uns eine Neubeschriftung der Variablennamen vorzunehmen. Wichtig! Die nicht umbenannten Variablen verbleiben auch weiterhin im Datensatz. Syntax: # Ohne Pipe rename(datensatz, rename(variableA = variable1)) # Mit Pipe datensatz %&gt;% rename(variableA = variable1) Mit dem Befehl rename() haben wir in unserem Datensatz ds die Variable variable1 in variableA umbenannt. Der neue Name muss folgend immer auf der linken Seite der Gleichung stehen. Beispielcode: # Neubeschriftung der Variablen Geschlecht (sex) und Alter (age) ds &lt;- allbus2018 %&gt;% select(sex, age) %&gt;% rename(Geschlecht = sex, Alter = age) ds #&gt; # A tibble: 3,477 x 2 #&gt; Geschlecht Alter #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 62 #&gt; 2 2 64 #&gt; 3 1 22 #&gt; 4 1 59 #&gt; 5 2 30 #&gt; 6 1 41 #&gt; 7 2 43 #&gt; 8 1 39 #&gt; 9 2 40 #&gt; 10 2 69 #&gt; # … with 3,467 more rows Mutate() Über die Funktion mutate() können wir neue Variablen aus schon bestehenden Variablen bilden. Vor allem erlaubt uns dieser Befehl mathematische Operationen an Variablen vorzunehmen. Wir kennen diese Befehl in SPSS als compute. Syntax: # Ohne Pipe mutate(datensatz, variable1 = Berechnung) # Mit Pipe datensatz %&gt;% mutate(variable1 = Berechnung) Die Funktion mutate() erstellt eine neue Variable mit dem Namen variable1, in der wir das Ergebnis aus Berechnung speichern. Beispielcode: # Berechung des Alters der Befragten aus ihrem Geburtsjahr in neuer Variable (Alter) ds &lt;- allbus2018 %&gt;% select(yborn, age) %&gt;% mutate(Alter = 2018-yborn) ds #&gt; # A tibble: 3,477 x 3 #&gt; yborn age Alter #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1956 62 62 #&gt; 2 1953 64 65 #&gt; 3 1995 22 23 #&gt; 4 1959 59 59 #&gt; 5 1987 30 31 #&gt; 6 1976 41 42 #&gt; 7 1975 43 43 #&gt; 8 1979 39 39 #&gt; 9 1977 40 41 #&gt; 10 1949 69 69 #&gt; # … with 3,467 more rows # Fast ;D # Um das korrekte Alter zu ermitteln, müssten wir natürlich noch den Geburtsmonat einbeziehen! Sofern Sie nur die neu gebildeten Variablen in ihrem Datensatz behalten möchten, bietet sich der Befehl transmute() als Erweiterung von mutate() an. Group_by() Gesetzt den Fall, dass wir bestimmte Operationen nicht auf den ganzen Datensatz anwenden wollen, sondern nur auf Teilgruppen, ist die Funktion group_by() die ideale Lösung für uns. Über group_by() wird unser Datensatz anhand einer Gruppierungsvariable (mit nominalen Ausprägungsmerkmalen) geteilt. Anschließende Funktionen werden auf jeden Teil angewendet, bevor sich der Datensatz nach Abschluss unserer Operationen über wieder zusammensetzt (split-apply-combine). group_by() wird deshalb meistens in Kombination mit anderen Funktionen verwendet. Um nach einer abgeschlossenen Operation die Gruppierung wieder zusammen zu setzen, nutzen wir ungroup(). So können wir wieder mit einem ungruppierten Datensatz weiterarbeiten. Unsere Ergebnisse können wir über mutate() einer neuen Variable zuweisen und es damit auf alle Fälle in unserem Datensatz übertragen. Syntax: # Ohne Pipe group_by(datensatz, variable1) # Mit Pipe datensatz %&gt;% group_by(variable1) Wir spalten also über die Funktion group_by() unseren Datensatz in Gruppen nach den Ausprägungsmerkmalen der variable1. Beispielcode: # Altersdurchschnitt nach Ost und West ds &lt;- allbus2018 %&gt;% select(age, eastwest, wghtpew) %&gt;% group_by(eastwest) %&gt;% # Wir werden in Kapitel 4 alles über gewichtete Objekte lernen (z.B. weighted_mean())! mutate(alterOstWest = weighted_mean(age, weights = wghtpew)) %&gt;% ungroup() ds %&gt;% select(eastwest, alterOstWest) #&gt; # A tibble: 3,477 x 2 #&gt; eastwest alterOstWest #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 50.7 #&gt; 2 2 53.9 #&gt; 3 1 50.7 #&gt; 4 2 53.9 #&gt; 5 2 53.9 #&gt; 6 1 50.7 #&gt; 7 1 50.7 #&gt; 8 1 50.7 #&gt; 9 1 50.7 #&gt; 10 2 53.9 #&gt; # … with 3,467 more rows Unter Verwendung von group_by() haben wir den Datensatz in zwei separate Teile geteilt und dann den Gruppenmittelwert für Ost- und Westdeutschland errechnet. Da wir unser Ergebnis allen Fällen zuweisen wollten, haben wir eine neue Variable über mutate() gebildet. Anschließend haben wir die Teile wieder über ungroup() “zusammengesetzt” (d.h. es ist wieder ein Datensatz) und so das Ergebnis allen Fällen zugewiesen. Als Resultat besitzen alle Fälle den Altersdurchschnitt in ihrem Bundesgebiet als neue Variable alterOstWest. Summarise() Die Funktion summarise() ermöglicht es uns Variablen zusammen zu fassen und deskriptive Kennzahlen zu berechnen. Im Gegensatz zu mutate() gibt summarise() aber nicht den Wert für jede Beobachtung als Output aus, sondern einen Wert für jede Gruppe. summarise() wird oft zusammen mit group_by() verwendet. Syntax: # Ohne Pipe summarise(datensatz, variable1 = funktion(variable)) # Mit Pipe datensatz %&gt;% summarise(variable1 = funktion(variable)) Mit der Funktion summarise() wurde in variable1 das Ergebnis aus function(variable) gespeichert. Hierbei wurde ein neuer Datensatz mit nur der Variable variable1 gebildet, die als einzigen Wert den Gruppenwert aus function(variable) besitzt. Beispielcode: # Altersdurchschnitt nach Ost und West ds &lt;- allbus2018 %&gt;% select(age, eastwest, wghtpew) %&gt;% group_by(eastwest) %&gt;% summarise(alterOstWest = weighted_mean(age, weights = wghtpew)) %&gt;% ungroup() ds %&gt;% select(eastwest, alterOstWest) #&gt; # A tibble: 2 x 2 #&gt; eastwest alterOstWest #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 50.7 #&gt; 2 2 53.9 Distinct() Die Funktion distinct() erlaubt uns einzigartige Werte in einem Vektor zu ermitteln. Syntax: # Ohne Pipe distinct(datensatz, variable1) # Mit Pipe datensatz %&gt;% distinct(datensatz, variable1) Beispielcode: # Geburtsjahre ds &lt;- allbus2018 %&gt;% select(yborn) %&gt;% distinct(yborn) %&gt;% arrange(yborn) ds #&gt; # A tibble: 78 x 1 #&gt; yborn #&gt; &lt;dbl&gt; #&gt; 1 1923 #&gt; 2 1924 #&gt; 3 1925 #&gt; 4 1926 #&gt; 5 1927 #&gt; 6 1928 #&gt; 7 1929 #&gt; 8 1930 #&gt; 9 1931 #&gt; 10 1932 #&gt; # … with 68 more rows Case_when() Über die Funktion case_when() lassen sich Kombinationen von Ausprägungsmerkmalen in neuen Variablen speichern - (Stw. Kombinationsindex). Der Befehl if-Befehl aus SPSS kommt diesem sehr nahe. Syntax: # Ohne Pipe case_when(datensatz$variable1 == 1 &amp; datensatz$variable2 == 2 ~ 1, datensatz$variable1 == 2 $ datensatz$variable2 == 1 ~ 2) # Mit Pipe datensatz %&gt;% mutate(variableA = case_when(variable1 == 1 &amp; variable2 == 2 ~ 1, variable1 == 2 $ variable2 == 1 ~ 2) Die Funktion case_when() erzeugt aus den Ausprägungsmerkmalen 1 und 2 der Variablen variable1 und variable2 eine neue Ausprägung 1. Das gleiche passiert auch in den nachfolgenden Operationen mit verschiedenen Wertpaaren der variable1 und variable2. Anmerkung: Die Funktion case_when() kann innerhalb einer Pipe praktisch nicht ohne eine “Speicherfunktion” auskommen. Entsprechend haben wir hier mutate() vorangestellt. Beispielcode: # Postmaterialismusindex nach Inglehart: Materialisten/Postmaterialisten ds &lt;- allbus2018 %&gt;% select(va01:va04, ingle) %&gt;% mutate( inglehartIndex = case_when( # Materialisten va01 == 1 &amp; va03 == 2 ~ 4, va01 == 2 &amp; va03 == 1 ~ 4, # Postmaterialisten va02 == 1 &amp; va04 == 2 ~ 1, va02 == 2 &amp; va04 == 1 ~ 1 ) ) # Vergleich mit dem beigelegten Inglehartindex aus dem Allbus # Wir müssten natürlich noch die Mischtypen berechnen! ds %&gt;% select(inglehartIndex, ingle) #&gt; # A tibble: 3,477 x 2 #&gt; inglehartIndex ingle #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 NA 3 #&gt; 2 NA 3 #&gt; 3 4 4 #&gt; 4 NA 2 #&gt; 5 NA 3 #&gt; 6 4 4 #&gt; 7 NA 2 #&gt; 8 NA 2 #&gt; 9 NA 3 #&gt; 10 NA 3 #&gt; # … with 3,467 more rows Rec() Nun folgt die wohl wichtigste Funktion in unserem Werkzeugkasten. So vereint die Funktion rec() eine Vielzahl von uns bekannten Funktionen z.B. to_numeric() und to_factor(), var_labels() und val_labels() und schafft darüber hinaus die Möglichkeit zur gezielten Rekodierung von Variablen. Diese Funktion entspricht dem Befehl recode aus SPSS. Syntax: # Ohne Pipe rec(datensatz, variable1, rec = &quot;1=1 [niedrig]; 2,4=2 [mittel]; 4:max=3 [hoch], else=copy, 99=NA&quot;, var.label = &quot;Variablenbeschriftung&quot;, to.factor = TRUE) # Mit Pipe datensatz %$% rec(variable1, rec = &quot;1=1 [niedrig]; 2,3=2 [mittel]; 4:max=3 [hoch], else=copy, 99=NA&quot;, var.label = &quot;Variablenbeschriftung&quot;, to.factor = TRUE) variable1 aus dem Datensatz datensatz wurde rekodiert und in einen Faktor konvertiert. So wurden alle Werte entsprechend neu zugewiesen und mit neuen Beschriftungen versehen. Zudem wurde die Variablenbeschriftung angepasst. Beispielcode: # Rekodierung von Bildungsabschlüssen ds &lt;- allbus2018 %&gt;% select(educ) %&gt;% mutate(bildung = rec(educ, rec = &quot;1,2=1 [gering]; 3,7=2 [mittel]; 4,5=3 [hoch]&quot;, var.label = &quot;Bildung kategorisiert&quot;, to.factor = T)) class(ds$educ) #&gt; [1] &quot;numeric&quot; attributes(ds$bildung) #&gt; $levels #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; #&gt; #&gt; $class #&gt; [1] &quot;factor&quot; #&gt; #&gt; $labels #&gt; gering mittel hoch #&gt; 1 2 3 #&gt; #&gt; $label #&gt; [1] &quot;Bildung kategorisiert&quot; view_df(ds) Data frame: ds ID Name Label Values Value Labels 1 educ ALLGEMEINER SCHULABSCHLUSS 1234567 OHNE ABSCHLUSSVOLKS-,HAUPTSCHULEMITTLERE REIFEFACHHOCHSCHULREIFEHOCHSCHULREIFEANDERER ABSCHLUSSNOCH SCHUELER 2 bildung Bildung kategorisiert 123 geringmittelhoch Set_na() Mit der Funktion set_na() wollen wir lernen, wie wir einzelne oder mehrere Ausprägungsmerkmale in NA konvertieren können. Syntax: # Ohne Pipe set_na(datensatz, variable1, na = c(1, 3)) # Mit Pipe datensatz %&gt;% set_na(variable1, na = c(1, 3)) Mit haben mit der Funktion set_na() in variable1 die Ausprägungsmerkmale 1 und 3 als NA definiert. Beispielcode: # Definition der Altersspanne 61 bis 99 als NA ds &lt;- allbus2018 %&gt;% select(age) %&gt;% set_na(age, na = 61:99) view_df(ds) Data frame: ds ID Name Label Values Value Labels 1 age ALTER: BEFRAGTE(R) range: 18-60 Referenz: Moosdorf, D. (2020): Kritik an sozialer Ungleichheit – Macht politisches Wissen den Unterschied?. In Tausendpfund, M. &amp; B. Westle (Hrsg.), Politisches Wissen in Deutschland: Empirische Analysen mit dem ALLBUS 2018 (S. 165–197). Wiesbaden: Springer VS. https://doi.org/10.1007/978-3-658-30492-8_6. "]]
