# Grafiken erstellen

In diesem Kapitel werden wir lernen, welche Werkzeuge uns R zur Erstellung von Grafiken zur Verfügung stellt und
wie uns das Paket `ggplot2` aus dem `tidyverse` ermöglicht durch explorative Datenanalyse verborgene Zusammenhänge zu entdecken, sowie 
Resultate darzustellen und zu kommunizieren. 

Im Gegensatz zum ursprünglichen Grafiksystem `R Base Graphics`, welches auf `Base R` aufsetzt, basiert `ggplot2` auf der intuitiven Syntax
`Grammar of Graphics`. Hiermit lassen sich durch eleganten, flexiblen und konsistenten Code sehr komplexe Grafiken erstellen und nahtlos mit den 
Funktionen des `tidyverse` verbinden. 

Achtung! `ggplot2` benötigt Datensätze im *long* Format. (siehe hierzu: [R for Data Science - Tidy Data](https://r4ds.had.co.nz/tidy-data.html))

Da Grafiken mit `ggplot2` immer nach dem gleichen Prinzip erstellt werden, ergeben sich immer folgende Schritte:

**Schritt 1:** Erstellung eines Objekts mit der Funktion `ggplot()`.

**Schritt 2:** Definition der Datengrundlage mit dem ersten Argument `data = datensatz`.

**Schritt 3:** Definition von “aesthetic mappings”, also der Wahl einer Variable für die x-Achse: `x = var1`, y-Achse: `y = var2`, 
Gewichtung: `weight = gewicht` und zur Gruppierung der Daten: `group bzw. colour, shape, linetype oder fill = var3` über die Funktion `mapping = aes()`. 

**Schritt 4:** Definition verschiedener "Layer" bzw. "Schichten". Hierbei definieren wir, was dargestellt werden soll - z.B. ein Histogramm oder Linien. 
Dabei wird uns in der Anzahl an Schichten kein Limit gesetzt. Die Funktionen beginnen dabei immer mit dem Präfix `geom_`, z.B. `geom_bar()` und werden über den
Operator `+` hinzugefügt.

Im Verlauf des Kapitels werden wir die einzelnen Schritte noch einmal vertiefen, gleichwohl wollen wir mit eingängigen Beispiel beginnen.

**Beispiel 1:** 

Grundlage unserer Grafik und damit erstes Argument der Funktion `ggplot()` ist der `allbus2018`. Aufbauend definieren wir in der Funktion `aes()`, welche Variablen in unserer Grafik auf welcher Achse abgebildet werden sollen. Da wir lediglich eine Abbildung der Häufigkeitsverteilung der Variable `im19` anstreben, müssen wir nur das Argument `x =` spezifizieren. Anschließend wird über das Argument `weight =` eine Gewichtung vorgenommen. Damit haben wir unser Fundament gelegt. Über den Operator `+` fügen wir nun weitere Schichte hinzu. Als erstes "Layer" fügen wir über die Funktion `geom_bar` das gewünschte Balkendiagramm hinzu. Die Funktion führt dabei voreingestellt über das Argument `stat = "count"` einen Zählbefehl aus, welcher uns in Folge die Häufigkeitswerte der einzelnen Ausprägungen ausgibt. Als weitere Argumente definieren wir noch die Farbe der Balken mit `fill =` und das Auslassen fehlender Werte über `na.rm = T`. Als Endpunkt fügen wir noch eine zweite Schicht hinzu, die uns mit der Funktion `labs()` ermöglicht alle Achsen frei zu Beschriften. Fertig!

```{r}
allbus2018 %>% 
  ggplot(aes(x = im19, weight = wghtpew)) +
  geom_bar(fill = "steelblue", na.rm = T) +
  labs(y = "Anzahl", title = "Häufigkeitsverteilung der Variable im19")
```

Die folgende Grafik erweitert unsere Fähigkeiten zusätzlich um vier Punkte. Durch die nahtlose Integration der Funktionen des `tidyverse` und `strengejacke` ist es uns möglich innerhalb eines Objekts sowohl die Daten zu manipulieren, als auch diese in die nachfolgende Grafik einzubeziehen. So war es in unserem Beispiel von Nöten die Grupperungsvariable `sex` (Geschlecht) erst zu einem Faktor zu konvertieren, um sie nachstehend nutzen zu können - Funktion `to_label()`. Weiterhin haben wir das Nettoeinkommen der Befragten mit dem Argument `y =` auf der y-Achse abgebildet und das Geschlecht der Befragten über das Argument `colour =` als Gruppierungvariable gewählt. Damit erlaubt uns `ggplot()` die einzelnen Datenpunkte farblich hervorzuheben, sowie über die Funktion `stat_summary()` einen Mittelwertvergleich zwischen beiden Gruppen über ein Liniendiagramm abzubilden. 

```{r}
allbus2018 %>% 
  to_label(sex) %>% 
  ggplot(aes(x = age, y = inc, colour = sex, weight = wghtpew)) +
  geom_point(na.rm = T, alpha = 0.1) +
  stat_summary(fun = "mean", geom = "line", na.rm = T, size = 0.8) +
  labs(x = "Alter", y = "Einkommen", colour = "Geschlecht", 
       title = "Mittleres Einkommen nach Alter und Geschlecht")
```

Nun wollen wir uns die einzelnen Schritte nochmal im Detail ansehen.

## Schritt 1: Plot-Objekt erstellen

```{r, echo=F, fig.align='center', out.width="75%"}
knitr::include_graphics("Bilder/ggplot-Funktion.png")
```

Wir beginnen mit einem Datensatz und erstellen ein Plot-Objekt mit der Funktion `ggplot()`. Als erstes Argument fügen wir unseren Datensatz ein `data = datensatz`. Hierbei bestehen zwei Möglichkeiten der Umsetzung.

```{r, echo=T, collapse=T, comment="#>"}
# Ohne Pipe
g <- ggplot(data = allbus2018)

# Mit Pipe
g <- allbus2018 %>% 
  ggplot()
```


## Schritt 2: Aesthetic mapping

Im zweiten Schritt definieren wir das zweite Argument `mapping =` über die Funktion `aes()` - "aesthetic mappings". Damit bestimmen wir welche Variablen benutzt werden sollen, um die Daten darzustellen. Im Folgenden wollen wir ergründen, inwieweit das Geschlecht der Befragten einen Einfluss auf ihr individuelles Nettoeinkommen `(inc)` hat. So definieren wir `sex` als Variable auf der x-Achse mit `x = sex` und die Variable `inc` mit `y = inc` auf der y-Achse. Da wir Gesamtdeutschland betrachten wollen, definieren wir noch mit `weight = wghtpew` das nötige Designgewicht. Der vorläufiger Befehl lautet entsprechend: `mapping = aes(x = sex, y = im21, weight = wghtpew)`. 
Zusätzlich erlaubt die Funktion `aes()` weitere Anpassungen über `fill =`, `colour =`, `shape =`, `linetype =` und `group =`. Diese Argumente helfen zum Einen der Gruppierungsvariable auf der x-Achse eine Farbe, Form oder Zugehörigkeit zuzuweisen, zum Anderen lässt sich damit aber auch eine dritte Variable `(z)` als Gruppierungsvariable (siehe Beispiel 2) zuweisen.

In unserem Beispiel wollen wir, dass die beiden Ausprägungsmerkmale von Geschlecht verschiedene Farben zugewiesen bekommen und die nachfolgenden Objekte entsprechend ausgefülllt werden. Der fertige Befehl lautet damit: `mapping = aes(x = sex, y = inc, weight = wghtpew, fill = sex, colour = sex)`. Das Argument `colour =` ist folglich ein Attribut für Linien und Punkte; das Argument `fill =` ist ein Attribut für Flächen.

**Wichtig!** Wenn wir die Funktion `aes()` innerhalb der Funktion `ggplot()` definieren, gelten sie für alle Schichten, d.h. für alle Elemente der Grafik. Wir können später die "mappings" auch für jede Schicht einzeln definieren und damit auf verschiedene Datensätze zugreifen, oder andere Variablen verwenden.

```{r, echo=T, collapse=T, comment="#>"}
g <- allbus2018 %>% 
  to_label(sex) %>% 
  ggplot(mapping = aes(
    x = sex,
    y = inc,
    weight = wghtpew,
    fill = sex,
    colour = sex
    ))
```

`g` ist damit ein "leeres" Plot-Objekt, dass noch nichts anzeigt, da wir noch keine "Layer" definiert haben. Das Objekt ist damit ein `ggplot2`-Objekt, welches im R-Studio Fenster `Plots` ausgegeben werden kann. Wir sehen folglich ein Grafikgerüst mit der richtigen Achsenzuweisung.

```{r, echo=T, collapse=T, comment="#>"}
g
```

## Schritt 3: Schichten ("Layer") hinzufügen

Dem Plot-Objekt `g` wollen wir nun mit den Funktionstypen `geom_` weitere Schichten beifügen. So addieren wir mit dem `+` Operator einfach ein weiteres "Layer" - `g + geom_`.

### Punktdiagramm

Als erstes möchten wir die einzelnen Beobachtungen als Datenpunkte abgetragen haben. Hierbei können wir entweder unsere Ausgangssytax optimieren, oder das Objekt `g` einfach erweitern.

**Anmerkung:** Mit dem Argument `na.rm = T` werden fehlende Werte in den Schichten außen vor gelassen und wir verhindern eine Warnmeldung. 

```{r, echo=T, collapse=T, comment="#>"}
# Ausgangssyntax optimieren
allbus2018 %>% 
  to_label(sex) %>% 
  ggplot(mapping = aes(x = sex, y = inc, weight = wghtpew, fill = sex, colour = sex)) +
  geom_point(na.rm = T)
  
# Objekt erweitern
g +
  geom_point(na.rm = T)
```

Wollen wir das Überlagern der Datenpunkte (overplotting) verhindern, können wir auch auf die Funktion `geom_jitter()` zurückgreifen. In Anwendung werden uns die Punkte nebeneinander gezeigt.

```{r, echo=T, collapse=T, comment="#>"}
g +
  geom_jitter(na.rm = T)
```

Mit dem Argument `width =` können wir zusätzlich bestimmen, wie breit die Streuung der Punkte sein soll.

```{r, echo=T, collapse=T, comment="#>"}
g +
  geom_jitter(width = 0.5, na.rm = T)
```

Weitere Argumente sind `size =` für die größe der Punkte und `alpha =` zur Bestimmung der Transparenz. Zudem lassen sich wie gehabt im Fenster `Help` über den Befehl `?geom_jitter` in der Konsole weitere Argumente einsehen. 

```{r, echo=T, collapse=T, comment="#>"}
g +
  geom_jitter(size = 1, alpha = 0.3, na.rm = T)
```

### Zentrale Tendenz und Streuung abbilden

Zur Darstellung der zentralen Tendenz und Streuung gibt uns `ggplot2` zusätzliche Schichten an die Hand. Genannt seien hier `geom_boxplot()` zur Darstellung von Boxplot-Diagrammen und `geom_violin()` für Violin-Diagramme.

```{r, echo=T, collapse=T, comment="#>"}
g +
  geom_boxplot(na.rm = T)
```

In einem Boxplot wird der Median abgetragen, d.h. das Rechteck repräsentiert die mittleren 50% und die Striche ("whiskers") zeigen den 1,5 * IQR (Interquantilbereich). Die einzelnen Punkte stellen Ausreisser dar. 

Wollen wir den Median sehen, müssen wir das Argument `fill = sex` weglassen.

```{r, echo=T, collapse=T, comment="#>"}
g <- allbus2018 %>% 
  to_label(sex) %>% 
  ggplot(mapping = aes(x = sex,
                       y = inc,
                       weight = wghtpew,
                       colour = sex))

g +
  geom_boxplot(na.rm = T)
```

Violin-Diagramme sind Boxplot-Diagrammen sehr ähnlichen, wenngleich sie nicht die Quantile, sondern ein "kernel density estimate" zeigen - d.h. eine Abbildung der Kerndichte. Hier bietet sich das Argument `fill = sex` zudem ideal an. 

```{r, echo=T, collapse=T, comment="#>"}
g <- allbus2018 %>% 
  to_label(sex) %>% 
  ggplot(mapping = aes(x = sex,
                       y = inc,
                       weight = wghtpew,
                       fill = sex))

g +
  geom_violin(na.rm = T)
```

Stellen wir fest, dass die Farbgebung immer wieder neu angepasst werden muss, sollten wir das mapping entsprechend anpassen.

```{r, echo=T, collapse=T, comment="#>"}
# Ausgang
g <- allbus2018 %>% 
  to_label(sex) %>% 
  ggplot(mapping = aes(x = sex,
                       y = inc,
                       weight = wghtpew))
```

```{r, echo=T, collapse=T, comment="#>"}
# Boxplot
g +
  geom_boxplot(aes(colour = sex), na.rm = T)
```

```{r, echo=T, collapse=T, comment="#>"}
# Violin
g +
  geom_violin(aes(fill = sex), na.rm = T)
```

### Mehrere Schichten kombinieren

So ist es uns auch möglich mehrere "Layer" zu kombinieren. So müssen wir lediglich mehrere `geom_` Funktionen mit dem `+` Operator verbinden:

```{r, echo=T, collapse=T, comment="#>"}
g +
  geom_violin(aes(fill = sex), na.rm = T) +
  geom_jitter(aes(colour = sex), alpha = 0.2, width = 0.4, na.rm = T)
```

## Verschiedene Grafiken für verschiedene Datentypen























